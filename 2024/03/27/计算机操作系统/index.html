
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>计算机操作系统 | 雲流のLowest World</title>
        <meta name="author" content="C1oudfL0w0" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/blog/images/croppedImage_cropped.jpg" />
        <!-- cdn挂掉的时候要可以引用本地 -->
<!-- <script src="https://cdn.staticfile.org/vue/3.2.45/vue.global.prod.min.js"></script> -->
<script src="/blog/js/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.2.1/css/all.min.css" />
<!--<link rel="stylesheet" href="/blog/css/all.min.css" />-->
<link rel="stylesheet" href="/blog/css/fonts.min.css" />
<link rel="stylesheet" href="/blog/css/search.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>

<!--改成了prismjs高亮-->

<script src="/blog/js/lib/prism.js"></script>
<link rel="stylesheet" href="/blog/css/prism.css" rel="stylesheet" />



<script src="/blog/js/lib/preview.js"></script>










<script src="/blog/js/lib/home.js"></script>

<link rel="stylesheet" href="/blog/css/main.css" />
<!-- 引入jQuery-->
<script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<!--<script src="/blog/js/jquery.min.js"></script>-->
<!-- 引入不蒜子-->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>    
        <script type="text/javascript" src="/blog/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/blog/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<!-- 引入clipboard -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
<script type="text/javascript" src="/blog/libs/codeBlock/codeCopy.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/blog/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>
    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <!--flag{never_g0nna g1ve_you up}-->
        
        <!-- 页面点击特效 -->
        <script type = "text/javascript" src = "/blog/js/love-click.js"></script>

        <!-- 浏览器标题 -->
         <script async type="text/javascript" src="/blog/js/FunnyTitle.js"></script>
         
        <!--动态背景-->
        <script type="text/javascript"
        color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

        <!--文章目录-->
        
    <div id="toc" class="toc-article">
    <h3><i class="fas fa-stream"></i>  目录</h3>
      <div class="toc-title"></div>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">引论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.1.</span> <span class="toc-text">提供接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">资源管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%8A%BD%E8%B1%A1"><span class="toc-number">2.2.3.</span> <span class="toc-text">资源抽象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">2.3.</span> <span class="toc-text">基本特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">2.3.1.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB"><span class="toc-number">2.3.2.</span> <span class="toc-text">共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F"><span class="toc-number">2.3.3.</span> <span class="toc-text">虚拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">2.3.4.</span> <span class="toc-text">异步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">运行机制与体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.4.1.</span> <span class="toc-text">状态转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text">操作系统结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">2.6.</span> <span class="toc-text">中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.7.</span> <span class="toc-text">系统调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-amp-%E7%89%B9%E5%BE%81"><span class="toc-number">3.1.</span> <span class="toc-text">定义&amp;特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCB"><span class="toc-number">3.2.</span> <span class="toc-text">PCB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">程序与进程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.5.</span> <span class="toc-text">基本状态与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%88%A9%E7%94%A8%E7%8E%87%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">3.5.1.</span> <span class="toc-text">CPU利用率的计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.6.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">3.6.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C"><span class="toc-number">3.6.2.</span> <span class="toc-text">执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2"><span class="toc-number">3.6.3.</span> <span class="toc-text">切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2"><span class="toc-number">3.6.4.</span> <span class="toc-text">终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-number">3.6.5.</span> <span class="toc-text">阻塞与唤醒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">进程通信（IPC）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.7.1.</span> <span class="toc-text">进程间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.2.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">共享存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">管道通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">3.7.2.3.</span> <span class="toc-text">消息传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E6%9C%BA%EF%BC%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.7.2.4.</span> <span class="toc-text">客户机－服务器系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">3.8.</span> <span class="toc-text">术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">3.8.1.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">3.8.2.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">3.8.3.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.8.4.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF"><span class="toc-number">3.8.5.</span> <span class="toc-text">饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">3.9.</span> <span class="toc-text">进程互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">3.9.1.</span> <span class="toc-text">互斥访问的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%A7%A3%E6%B3%95"><span class="toc-number">3.9.1.1.</span> <span class="toc-text">软件解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%A7%A3%E6%B3%95"><span class="toc-number">3.9.1.2.</span> <span class="toc-text">硬件解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1"><span class="toc-number">3.10.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">3.10.1.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">3.10.1.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#demo%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8D%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.10.1.2.</span> <span class="toc-text">demo：生产者－消费者问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">3.10.2.</span> <span class="toc-text">管程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-1"><span class="toc-number">3.10.2.1.</span> <span class="toc-text">功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8IPC%E9%97%AE%E9%A2%98"><span class="toc-number">3.11.</span> <span class="toc-text">经典IPC问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8D%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.11.1.</span> <span class="toc-text">多生产者－多消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%EF%BC%8D%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.11.2.</span> <span class="toc-text">读者－写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">3.11.2.1.</span> <span class="toc-text">解法一：读者优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%86%99%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">3.11.2.2.</span> <span class="toc-text">解法二：写者优先</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">3.11.3.</span> <span class="toc-text">哲学家进餐问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">与进程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-2"><span class="toc-number">4.2.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">4.3.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">5.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">三个问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA"><span class="toc-number">5.2.</span> <span class="toc-text">调度时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">调度过程（进程切换）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%B1%82%E6%AC%A1"><span class="toc-number">5.4.</span> <span class="toc-text">调度层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="toc-number">5.5.</span> <span class="toc-text">作业调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%A0%87"><span class="toc-number">5.6.1.</span> <span class="toc-text">指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.6.2.</span> <span class="toc-text">批处理系统的调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.6.3.</span> <span class="toc-text">交互式系统的调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.6.4.</span> <span class="toc-text">实时系统调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">5.7.</span> <span class="toc-text">进程死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A6%82%E8%BF%B0"><span class="toc-number">5.7.1.</span> <span class="toc-text">死锁概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%BB%BA%E6%A8%A1"><span class="toc-number">5.7.2.</span> <span class="toc-text">死锁建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">5.7.3.</span> <span class="toc-text">处理死锁的策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%B8%B5%E9%B8%9F%E7%AE%97%E6%B3%95"><span class="toc-number">5.7.3.1.</span> <span class="toc-text">鸵鸟算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">5.7.3.2.</span> <span class="toc-text">死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">5.7.3.2.1.</span> <span class="toc-text">银行家算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">5.7.3.3.</span> <span class="toc-text">预防死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-number">5.7.3.4.</span> <span class="toc-text">死锁检测和死锁恢复</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">6.</span> <span class="toc-text">存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80"><span class="toc-number">6.1.</span> <span class="toc-text">内存基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">6.2.</span> <span class="toc-text">内存保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">6.3.</span> <span class="toc-text">程序的装入和链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">6.3.1.</span> <span class="toc-text">静态重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">6.3.2.</span> <span class="toc-text">动态重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-number">6.3.3.</span> <span class="toc-text">程序的链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">连续分配存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">6.4.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">6.4.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">6.4.3.</span> <span class="toc-text">动态分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%88FF%EF%BC%89"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">首次适应算法（FF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%AC%A1%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%88NF%EF%BC%89"><span class="toc-number">6.4.3.2.</span> <span class="toc-text">下次适配算法（NF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%88BF%EF%BC%89"><span class="toc-number">6.4.3.3.</span> <span class="toc-text">最佳适配算法（BF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%AE%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%88WF%EF%BC%89"><span class="toc-number">6.4.3.4.</span> <span class="toc-text">最差适配算法（WF）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">6.5.</span> <span class="toc-text">交换技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-number">6.5.1.</span> <span class="toc-text">覆盖技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF-1"><span class="toc-number">6.5.2.</span> <span class="toc-text">交换技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84"><span class="toc-number">6.6.</span> <span class="toc-text">地址空间结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">6.7.</span> <span class="toc-text">分页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.7.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.7.2.</span> <span class="toc-text">地址转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">6.7.3.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">6.7.4.</span> <span class="toc-text">基址变换机构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">6.7.5.</span> <span class="toc-text">地址转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-number">6.8.</span> <span class="toc-text">快表</span></a></li></ol></li></ol>
    </div>
  
        
        <!--返回顶部-->
        <div id="totop" style="position:fixed;bottom:50px;right:60px;font-size: 48px;cursor: pointer;z-index: 10;">
            <a title="返回顶部">↑</a>
            </div>
        <script src="/blog/js/totop.js"></script>

        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>第一次加载文章图片可能会花费较长时间</p>
                    <p>要不挂个梯子试试？（x</p>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/blog/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/blog/">
            <span>雲流のLOWEST WORLD</span>
        </a>
        
        <a href="/blog/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/blog/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/blog/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/blog/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/blog/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
        <a href="/blog/links">
            <i class="fa-solid fa-link fa-fw"></i>
            <span>&ensp;Links</span>
        </a>
        
        <a href="/blog/search">
            <i class="fa-solid fa-search fa-fw"></i>
            <span>&ensp;Search</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;雲流のLOWEST WORLD</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/blog/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/blog/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/blog/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/blog/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/blog/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
            <a href="/blog/links">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-link fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Links</div>
                </div>
            </a>
            
            <a href="/blog/search">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-search fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Search</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>计算机操作系统</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/27
        </span>
        
        <span class="category">
            <a href="/blog/categories/Basic/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Basic
            </a>
        </span>
        
        
        <!--文章字数统计-->
        
            
<div style="margin-top:10px;">
    <span class="post-time">
      <span class="post-meta-item-icon">
        <i class="fa fa-keyboard-o"></i>
        <span class="post-meta-item-text">  字数统计: </span>
        <!-- 安装插件npm install hexo-wordcount --save -->
        <span class="post-count">14.3k字</span>
      </span>
    </span>

    <span class="post-time">
      &nbsp; | &nbsp;
      <span class="post-meta-item-icon">
        <i class="fa fa-hourglass-half"></i>
        <span class="post-meta-item-text">  阅读时长: </span>
        <span class="post-count">49分</span>
      </span>
    </span>
    
    <!--不蒜子统计访问数-->
    <span id="busuanzi_container_page_pv">
    &nbsp; | &nbsp;
    总文章阅读量：<span id="busuanzi_value_page_pv"></span>次
    </span>
</div>

          
    </div>
    
    <div class="content" v-pre>
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机408之操作系统</p>
<p>参考：上课的课件和《计算机操作系统（慕课版）》</p>
<span id="more"></span>

<hr>
<h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514222255415.png" alt="image-20240514222255415"></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境</p>
<p>是一种（系统）软件，是安装在计算机硬件上的第一层软件</p>
<p>shell：用户交互程序</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514222426446.png" alt="image-20240514222426446"></p>
<hr>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><p>为用户提供接口</p>
</li>
<li><p>对计算机资源进行管理</p>
</li>
<li><p>对计算机资源进行抽象</p>
</li>
</ul>
<h3 id="提供接口"><a href="#提供接口" class="headerlink" title="提供接口"></a>提供接口</h3><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514222531059.png" alt="image-20240514222531059"></p>
<h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><ul>
<li>处理机管理：用于分配和控制处理机</li>
<li>存储器管理：负责内存的分配与回收</li>
<li>IO设备管理：负责IO设备的分配与操作</li>
<li>文件管理：用于实现对文件的存取、共享和保护</li>
</ul>
<p>实现资源共享的方式——多路复用</p>
<hr>
<h3 id="资源抽象"><a href="#资源抽象" class="headerlink" title="资源抽象"></a>资源抽象</h3><p>抽象与现实，类似于类与实例</p>
<p>操作系统的抽象，是把硬件的具体细节隐藏了，而将一个清晰的、优雅的、一致的<strong>接口</strong>提供给用户。例如，CPU，鼠标等设备都被操作系统抽象成为了<strong>文件（数据结构）</strong>，用户通过命令来操作它们</p>
<p>linux一切皆文件.jpg：</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514223049739.png" alt="image-20240514223049739"></p>
<hr>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><p><strong>并发和共享</strong>是操作系统最基本的特征，并发和共享互为存在条件</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li><p>并发性（concurrency）是指两个或多个事件在<strong>同一时间间隔内</strong>发生。在宏观上是同时发生的，在微观上却仍是交替发生的</p>
</li>
<li><p>并行性（parallel）是指两个或多个事件在<strong>同一时刻</strong>发生（多处理器才可能真正实现）</p>
</li>
</ul>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>系统中的资源可供内存中多个并发执行的<strong>进程</strong>共同使用</p>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>在操作系统中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为“虚拟”</p>
<ul>
<li><p>时分复用：虚拟处理机技术、虚拟设备技术</p>
</li>
<li><p>空分复用：虚拟存储技术</p>
</li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情</p>
<hr>
<h2 id="运行机制与体系结构"><a href="#运行机制与体系结构" class="headerlink" title="运行机制与体系结构"></a>运行机制与体系结构</h2><p>操作系统通过<strong>指令</strong>来运行处理器</p>
<ul>
<li>特权指令：具有高级别权限，不允许用户程序使用</li>
<li>非特权指令：普通级别权限，如加减乘除等运算指令</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><ul>
<li>用户态-&gt;内核态：通过中断&#x2F;异常&#x2F;陷入机制实现，且中断是唯一途径</li>
<li>内核态-&gt;用户态：通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”</li>
</ul>
<hr>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><ul>
<li><p>单体系统（无结构系统）：整个操作系统在内核态以单一程序的方式运行。该结构中，系统中每个过程可以自由调用其他过程。整个系统以过程集合的方式编写，链接成一个大型可执行二进制程序</p>
</li>
<li><p>层次式系统：THE系统</p>
</li>
<li><p>微内核：将系统分成若干小的、良好定义的模块，且只有其中一个模块——<strong>微内核运行在内核态</strong>，其余模块则作为普通用户进程运行</p>
</li>
<li><p>客户端-服务器模式：微内核的一种变体，如Web服务器</p>
</li>
<li><p>虚拟机</p>
</li>
<li><p>外核</p>
</li>
</ul>
<hr>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断：CPU对系统发生的某个事件做出的某种反应。当系统接收到一个中断信号时，CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，完成后返回断点，继续执行被打断的程序</p>
<p>异常：中断的一种类型</p>
<ul>
<li>中断的引入：为了支持CPU和设备间的并行操作（多道程序），即实现多道程序并发执行</li>
<li>异常的引入：表示CPU执行指令时本身出现的问题。如运算中遇到除零等错误，此时硬件改变了CPU当前的执行流程，自动转到相应的错误处理程序或异常处理程序或执行系统调用</li>
</ul>
<p>中断&#x2F;异常的作用：</p>
<ul>
<li>及时处理设备发来的中断请求</li>
<li>使操作系统能捕获用户程序提出的服务请求</li>
<li>防止用户程序执行过程中的破坏活动等</li>
</ul>
<p>发生中断就意味着需要操作系统介入，开展管理工作。由于操作系统的管理操作（如进程切换、分配IO设备等）需要使用特权指令，因此CPU要<strong>从用户态转为核心态</strong></p>
<hr>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>应用程序通过<strong>系统调用（陷入机制，由用户态-&gt;内核态）</strong>请求操作系统的服务</p>
<p>系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是<strong>与资源有关的操作（如存储分配、IO操作、文件管理等）</strong>，都必须通过<strong>系统调用</strong>的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的<strong>稳定性和安全性</strong>，防止用户进行非法操作</p>
<p>注：系统调用的处理是在<strong>核心态</strong>进行的</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514225028039.png" alt="image-20240514225028039"></p>
<p>实例：C语言read函数的调用</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">count <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// fd：指定文件</span>
<span class="token comment">// buffer：指向缓冲区</span>
<span class="token comment">// nbytes：要读出的字节数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514225133792.png" alt="image-20240514225133792"></p>
<hr>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="定义-amp-特征"><a href="#定义-amp-特征" class="headerlink" title="定义&amp;特征"></a>定义&amp;特征</h2><blockquote>
<p>进程是指在系统中能够<strong>独立运行</strong>并作为<strong>资源分配的基本单位</strong>，是由一组机器指令、数据和堆栈等组成的活动实体</p>
</blockquote>
<p>进程实体（进程映像，可以认为是进程）：由<strong>程序段、相关的数据段和PCB</strong>三部分构成，是静态的；进程是进程实体的运行过程，是动态的</p>
<p>进程的特征：</p>
<ol>
<li>动态性：进程的实质是程序的执行过程；而程序只是一组有序指令的集合，并存放在某种介质上</li>
<li>并发性：内存中有多个进程实体，各进程可并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>异步性：各进程按各自独立的、不可预知的速度向前推进，系统提供<strong>同步机制</strong>来解决<strong>异步问题</strong></li>
</ol>
<hr>
<h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p>进程控制块（PCB）：操作系统配置的一个专门的数据结构。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程</p>
<p>PCB是<strong>进程存在的唯一标志</strong>。创建进程，实质上是<strong>创建进程实体中的PCB</strong>；而撤销进程，实质上是撤销进程实体中的PCB</p>
<p>PCB的构成：</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512163957084.png" alt="image-20240512163957084"></p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512164559547.png" alt="image-20240512164559547"></p>
<ul>
<li>标识符：与进程相关的唯一标识符，用来区分其他进程</li>
<li>状态：若进制正在执行，则进程处于运行态</li>
<li>优先级：相对于其他进程的优先顺序</li>
<li>程序计数器：程序中即将执行的下一条指令的地址</li>
<li>内存指针：包括程序代码和进程相关数据的指针，以及与其他进程共享内存块的指针</li>
<li>上下文数据：进程执行时处理器的寄存器中的数据</li>
<li>IO状态信息：包括显式IO请求，分配给进程的IO设备和被进程使用的文件列表等</li>
<li>记账信息：包括处理器时间总和，使用的时钟数总和，时间限制等</li>
</ul>
<p>组织方式：</p>
<ul>
<li><p>线性方式：把所有的PCB都组织在一张线性表中，表的首地址存放在内存专用区</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512165350169.png" alt="image-20240512165350169"></p>
</li>
<li><p>链接方式：把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列，如就绪队列。通常，将优先级高的进程排在前面</p>
<p>（图中最右边的指针表示队列中下一个优先级的PCB指针，0表示队列结束）</p>
<p>（注：单处理器系统中，同一时刻只有一个进程会处于运行状态）</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512165554956.png" alt="image-20240512165554956"></p>
<p>如果系统中有许多处于就绪状态的进程，通常将它们按一定的策略（如优先级）排队，称为<strong>就绪队列</strong></p>
<p>如果将处于阻塞状态的进程进行排队，称为<strong>阻塞队列</strong>。而为了减少队列操作的开销，系统会设置多个阻塞队列</p>
</li>
<li><p>索引方式：系统根据所有进程状态，建立几张索引表，并把索引表的首地址记录在内存的专用单元中。在每个索引表中，记录具有相应状态的PCB在PCB表中的首地址</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512170205528.png" alt="image-20240512170205528"></p>
</li>
</ul>
<p>操作系统会提供一个唯一<strong>仲裁程序</strong>例程来保护PCB，这里涉及到系统性能、软件信任度等问题</p>
<hr>
<h2 id="程序与进程的区别"><a href="#程序与进程的区别" class="headerlink" title="程序与进程的区别"></a>程序与进程的区别</h2><ol>
<li><strong>进程也是一种程序</strong>，是专门负责处理其它程序如何在操作系统中运行的程序</li>
<li>进程能<strong>描述并发</strong>，而程序没有这个功能</li>
<li>进程是<strong>动态</strong>的，程序是<strong>静态</strong>的（根本区别）</li>
<li>进程有生命周期，是<strong>短暂的</strong>；而程序相对长（存在磁盘里）</li>
<li>一个程序可以对应多个进程（程序多开）</li>
<li>进程具有创建其它进程的功能</li>
</ol>
<hr>
<h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p>父进程：创建进程的进程<br>子进程：被创建的进程，子进程又可以创建自己的子进程（即父进程的孙进程）。子进程可以继承父进程所拥有的资源，如父进程所打开的文件和分配到的缓冲区</p>
<p>Unix &#x2F; Linux 系统为树型结构，可以共同组成一个进程家族（进程组）</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512171035976.png" alt="image-20240512171035976"></p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512171113560.png" alt="image-20240512171113560"></p>
<p>Windows 系统没有进程层次的概念，所有进程都是地位相同的，进程之间的关系是获得句柄（作用相当于一个令牌，可以用来控制被创建的进程）与否、控制与被控制的关系</p>
<p>父进程使用<strong>句柄</strong>来控制子进程，然而，父进程可以把句柄传送给其它进程，这样就不存在进程层次了</p>
<hr>
<h2 id="基本状态与转换"><a href="#基本状态与转换" class="headerlink" title="基本状态与转换"></a>基本状态与转换</h2><p>3种基本状态：</p>
<ul>
<li><p>就绪态（ready）：进程已处于可运行的状态，只要获得CPU资源，就可立即运行</p>
</li>
<li><p>运行态（running）：该时刻进程实际占用CPU</p>
</li>
<li><p>阻塞&#x2F;等待态（block&#x2F;waiting）：正在执行的进程由于发生某事件（如I&#x2F;O请求、申请缓冲区失败等）而暂时无法继续执行</p>
</li>
</ul>
<p>基本状态转换：三状态模型</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1711539242316.jpg" alt="1711539242316.jpg"></p>
<ol>
<li>就绪-&gt;运行：调度程序选择一个新的进程运行</li>
<li>运行-&gt;就绪：运行进程用完了时间片且被换出；一个高优先级进程抢占正在运行的进程</li>
<li>运行-&gt;阻塞：当一个进程等待某个事件发生时</li>
<li>阻塞-&gt;就绪：进程所等待的事件发生了，如I&#x2F;O操作完成，产生中断</li>
</ol>
<p>（不存在 阻塞态 -&gt; 运行态 ）</p>
<p>再认识两种状态：</p>
<ul>
<li>创建态（或称新建态，new）：进程正在被创建，操作系统为进程分配资源、初始化PCB</li>
<li>终止态（或称结束态，terminated）：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li>
</ul>
<p>五状态模型：</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512172936740.png" alt="image-20240512172936740"></p>
<h3 id="CPU利用率的计算"><a href="#CPU利用率的计算" class="headerlink" title="CPU利用率的计算"></a>CPU利用率的计算</h3><p>因为只有所有进程都处于阻塞态（如等待I&#x2F;O）或者就绪队列中无进程时，CPU才会空闲下来，所以<code>CPU利用率 = 1 - 进程等待I/O的概率 * 进程数</code></p>
<hr>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>是对系统中的所有进程实施有效的管理，具有<strong>进程创建</strong>、<strong>进程执行</strong>、<strong>进程切换</strong>以及<strong>进程终止（撤销）</strong>等功能</p>
<p>本质就是实现进程状态转换</p>
<p>一般由OS内核中的原语来实现：</p>
<ul>
<li>原语处于系统最底层，是最接近硬件的部分，运行事件较短、调用频繁。其最大的特点是执行期间<strong>不允许中断</strong>（即操作的原子性）</li>
<li>原语采用“关中断”和“开中断”指令实现。开关中断指令的权限很大，是运行在<strong>核心态下的特权指令</strong></li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>引起进程创建的事件：</p>
<ol>
<li>用户登录：系统初始化</li>
<li>作业调度：一个批处理作业的初始化</li>
<li>提供服务：正在运行的程序执行了<strong>创建进程的系统调用</strong></li>
<li>应用请求：用户请求创建一个新进程（上面3种都是由系统内核为用户创建一个新进程）</li>
</ol>
<p>启动操作系统时会创建若干个进程，一些是前端交互进程，一些是后端守护进程（daemon）</p>
<p>进程的创建：</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配其运行所需的资源</li>
<li>初始化PCB</li>
<li>如果进程就绪队列能够接纳新进程，就将新进程插入就绪队列</li>
</ol>
<ul>
<li>通常，在系统调用<code>fork()</code>后，进程会使用另一个系统调用<code>exec()</code>，用新程序来取代进程的内存空间</li>
</ul>
<p>创建的一般步骤：</p>
<ol>
<li>为新进程分配一个唯一的进程标识符</li>
<li>为进程分配空间</li>
<li>初始化进程控制块</li>
<li>设置正确的链接：新进程进状态队列链表</li>
<li>创建或扩充其他数据结构：维护记账文件</li>
</ol>
<hr>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>处理器至少支持两种执行模式：特权模式和用户模式</p>
<ul>
<li>特权模式：也称为系统模式、控制模式或内核模式</li>
<li>用户模式：通常是用户程序运行的模式</li>
</ul>
<p>设计两种模式是为了保护操作系统和重要的操作系统表不受用户程序的干扰</p>
<p>系统通过程序状态字<code>PSW</code>来判断当前模式</p>
<hr>
<h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>进程的挂起：暂停运行</p>
<ul>
<li>终端用户的需要</li>
<li>父进程的请求</li>
<li>负荷调节的需要</li>
<li>操作系统的需要</li>
</ul>
<p>切换的时机：进程切换可在<strong>操作系统从当前正在运行进程中获得控制权的任何时刻</strong>发生，如一个进程从运行态切换为就绪态</p>
<ul>
<li>上下文（context）：进程执行时处理器的寄存器中的数据</li>
</ul>
<p>切换的成因：</p>
<ul>
<li>系统中断，如时钟中断、IO中断或者内存失效</li>
<li>操作系统确定出现错误或异常条件</li>
<li>系统调用，正运行用户进程执行了一个请求IO操作的指令，此时该调用会转移到作为系统代码一部分的一个例程</li>
</ul>
<p>切换的一般步骤：</p>
<ol>
<li>决定是否作切换以及是否允许作切换</li>
<li>保存当前进程的进程上下文（包括CPU的所有寄存器中的值、进程的状态以及堆栈中的内容）</li>
<li>更新当前处于运行态进程的PCB以及其他相关字段的更新，如退出运行态的原因和记账信息</li>
<li>把该进程的PCB移到相应的队列</li>
<li>使用进程调度算法，选择某个就绪状态的进程</li>
<li>更新所选进程的PCB</li>
<li>更新内存管理数据结构（切换新的页表，然后使用新的虚拟地址空间）</li>
<li>载入程序计数器和其他寄存器先前的值，将进程上下文恢复为所选进程上次退出运行态时的上下文</li>
</ol>
<hr>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>事件：</p>
<ul>
<li><p>正常退出（自愿的）</p>
</li>
<li><p>出错退出（自愿的）：如打开不存在的文件，则系统会退出</p>
</li>
<li><p>严重错误（非自愿的）：指的是进程引起的错误，比如执行一条非法指令，引用不存在的内存或是除数为零等</p>
</li>
<li><p>被其他进程杀死（非自愿的）：Unix中的系统调用是<code>kill</code>，Windows中使用<code>TerminateProcess</code>函数</p>
</li>
</ul>
<hr>
<h3 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="headerlink" title="阻塞与唤醒"></a>阻塞与唤醒</h3><p>事件：</p>
<ul>
<li>向系统请求共享资源失败</li>
<li>等待某种操作的完成</li>
<li>新数据尚未到达</li>
<li>等待新任务的到达</li>
</ul>
<hr>
<h2 id="进程通信（IPC）"><a href="#进程通信（IPC）" class="headerlink" title="进程通信（IPC）"></a>进程通信（IPC）</h2><p>指进程之间的信息交换</p>
<p>进程是分配系统资源的单位（包括内存地址空间），因此各个进程拥有<strong>独立的内存地址空间</strong>，一个进程不能直接访问另一个进程的地址空间</p>
<h3 id="进程间的关系"><a href="#进程间的关系" class="headerlink" title="进程间的关系"></a>进程间的关系</h3><table>
<thead>
<tr>
<th>感知程度</th>
<th>关系</th>
<th>一个进程对其他进程的影响</th>
<th>潜在的控制问题</th>
</tr>
</thead>
<tbody><tr>
<td>进程间不知道对方的存在</td>
<td>竞争</td>
<td>一个进程的结果与另一个进程的活动无关；进程的执行时间可能会受到影响</td>
<td>互斥；死锁；饥饿</td>
</tr>
<tr>
<td>进程间接知道对方存在（共享对象）</td>
<td>共享合作</td>
<td>一个进程的结果可能取决于另一进程获得的信息；进程的执行时间可能会受到影响</td>
<td>互斥；死锁；饥饿；数据一致性</td>
</tr>
<tr>
<td>进程直接知道对方的存在（通信）</td>
<td>通信合作</td>
<td>一个进程的结果可能取决于另一进程获得的信息；进程的执行时间可能会受到影响</td>
<td>死锁；饥饿</td>
</tr>
</tbody></table>
<hr>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240513225504009.png" alt="image-20240513225504009"></p>
<ol>
<li>基于共享<strong>数据结构</strong>的通信方式：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方法</li>
<li>基于共享<strong>存储区</strong>的通信方式：在内存中划出一块存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，速度快，是一种高级通信方式</li>
</ol>
<hr>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><blockquote>
<p>管道： 指用于连接一个<strong>读进程</strong>和一个<strong>写进程</strong>以实现她们之间通信的一个共享文件，即pipe文件，其实就是在内存中开辟一个固定的缓冲区</p>
</blockquote>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240513225408966.png" alt="image-20240513225408966"></p>
<p>管道机制的协调能力：</p>
<ol>
<li>互斥：防止进程进入竞争条件</li>
<li>同步</li>
<li>确定对方是否存在</li>
</ol>
<hr>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240513225709634.png" alt="image-20240513225709634"></p>
<p>以<strong>格式化的消息</strong>为单位，将通信的数据封装在消息（队列）中，并利用系统提供的一组通信命令（原语）在进程间传递消息，完成进程间的数据交换。</p>
<p>该方法属于高级通信方式，主要方式：<strong>直接通信方式</strong>和<strong>间接通信方式</strong></p>
<ul>
<li>直接通信方式：消息直接发送到接收进程的消息缓冲队列上</li>
<li>间接通信方式：也称为信箱通信方式，消息要先发送到中间实体（信箱）中</li>
</ul>
<hr>
<h4 id="客户机－服务器系统"><a href="#客户机－服务器系统" class="headerlink" title="客户机－服务器系统"></a>客户机－服务器系统</h4><p>3种实现方法：</p>
<ol>
<li>套接字</li>
<li>远程过程调用</li>
<li>远程方法调用</li>
</ol>
<hr>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原语：由若干条指令组成的，用于完成一定功能的一个过程，它们是<strong>原子操作</strong>；一个操作中的所有动作要么全做，要么全不做；<strong>原子性</strong>保证了并发进程的隔离</p>
<p>竞争条件：两个或多个进程读写某些共享数据，且最后的结果取决于这些进程运行的精确时序</p>
<p>互斥：由于各进程要求使用共享资源（变量、文件等），而这些资源需要排他性使用（独占），各进程之间竞争使用这些资源的关系</p>
<hr>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><blockquote>
<p>各个进程中对某个<strong>临界资源</strong>（系统中某些资源一次只允许一个进程使用，如系统中的大多数物理设备以及栈、变量和表格等）实施操作的程序（代码）片段</p>
</blockquote>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240513231352172.png" alt="image-20240513231352172"></p>
<p>使用原则：</p>
<ol>
<li>空闲让进：没有进程在临界区时，想进入临界区的进程可以进入</li>
<li>忙则等待：不允许两个进程同时处于临界区中</li>
<li>让权等待：临界区外运行的进程不得阻塞其他进程进入临界区</li>
<li>有限等待：不得使进程无限期等待进入临界区</li>
</ol>
<hr>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>是指为完成某种任务而建立的两个或多个进程，这些进程的执行存在某种时序关系，需要互相协作、合作</p>
<p>具体地，一个进程运行到某一个点时，要求另一个伙伴进程为它提供<strong>消息</strong>，在未获得消息之前，该进程进入<strong>睡眠（阻塞态）</strong>，获得消息后被<strong>唤醒</strong>进入<strong>就绪态</strong></p>
<hr>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>一组进程中，每个进程都<strong>无限等待</strong>被该组进程中另一进程所占有的资源，因而永远无法得到的资源。即大家都占用着对方想要的资源</p>
<p>活锁：拿到资源却又相互释放不执行</p>
<hr>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个可运行进程尽管能继续执行，但被调度程序无限期地忽视，而不能被调度执行的情形</p>
<p>例子：</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">如打印机分配案例。一种可能的方案是把打印机分配给打印最小文件的进程。
如果在一个繁忙的系统中，某个进程有一个很大的文件要打印，这个进程可能永远得不到打印机。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><blockquote>
<p>进程互斥指的是当一个进程访问某临界资源时，其他进程必须等待其释放之后才能去访问该资源（即互斥访问）</p>
</blockquote>
<p>进程互斥描述的是进程（对共享资源）的<strong>竞争关系</strong>；而进程同步描述的是进程（对共享资源）的<strong>合作关系</strong></p>
<p>互斥是同步的一种特殊情况</p>
<p>对临界资源的互斥访问：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
	entry section<span class="token punctuation">;</span> <span class="token comment">// 进入区，负责检查能否可进入的代码</span>
	critical section<span class="token punctuation">;</span> <span class="token comment">// 临界区，访问临界资源的代码</span>
	exit section<span class="token punctuation">;</span> <span class="token comment">// 退出区，负责解除对资源的占用的代码</span>
	remainder section<span class="token punctuation">;</span> <span class="token comment">// 剩余区，做其他处理的代码</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="互斥访问的实现方法"><a href="#互斥访问的实现方法" class="headerlink" title="互斥访问的实现方法"></a>互斥访问的实现方法</h3><h4 id="软件解法"><a href="#软件解法" class="headerlink" title="软件解法"></a>软件解法</h4><p>单标志法（严格轮换）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">global boolean free <span class="token operator">=</span> false <span class="token comment">// 临界区空闲标志，true为有进程在临界区，false反之</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>进程P、Q：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>free<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 忙等待</span>
free <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">// lock()</span>
<span class="token comment">// 临界区</span>
free <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// unlock()</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>单标志轮换法</p>
<p>进程P：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>not turn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区</span>
turn <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进程Q：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>turn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区</span>
turn <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>双标志法</p>
<p>进程P：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
pturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>qturn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区</span>
pturn <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进程Q：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
qturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>pturn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区</span>
qturn <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>违反了有限等待</p>
<p>Dekker解法——三标志法</p>
<p>进程P：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
pturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>qturn<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        pturn <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// 临界区</span>
turn <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
pturn <span class="token operator">=</span> false
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进程Q：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
qturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>pturn<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        qturn <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        qturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// 临界区</span>
turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
pturn <span class="token operator">=</span> false
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Peterson解法</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TRUE</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">2</span></span></span>
<span class="token keyword">int</span> turn<span class="token punctuation">;</span>
    <span class="token keyword">int</span> interested<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 兴趣数组，初始值均为FALSE</span>
    
<span class="token keyword">void</span> <span class="token function">enter_region</span><span class="token punctuation">(</span><span class="token keyword">int</span> process<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> other<span class="token punctuation">;</span>
    other <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> process<span class="token punctuation">;</span>
    interested<span class="token punctuation">[</span>process<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>
    turn <span class="token operator">=</span> process<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> process <span class="token operator">&amp;&amp;</span> interested<span class="token punctuation">[</span>other<span class="token punctuation">]</span> <span class="token operator">==</span> TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">leave_region</span><span class="token punctuation">(</span><span class="token keyword">int</span> process<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    interested<span class="token punctuation">[</span>process<span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进程i：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">enter_region</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区</span>
<span class="token function">leave_region</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="硬件解法"><a href="#硬件解法" class="headerlink" title="硬件解法"></a>硬件解法</h4><p>开关中断：</p>
<p>TSL（Test and Set Lock）指令：</p>
<p>XCHG指令（或Swap交换指令）：</p>
<hr>
<h2 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h2><p>允许多个进程从临界区里读数据，仅是读不写</p>
<p>同步机制：信号量机制和管程机制</p>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><blockquote>
<p>两个或多个进程通过简单的信号进行合作，可以强迫一个进程在某个位置停止，直到它接收到一个特定的信号</p>
</blockquote>
<p>信号量：可以是一个整数，也可以是更复杂的记录型变量</p>
<p>用户进程通过使用操作系统提供的一对<strong>原语（P、V操作）</strong>对信号量进行操作，从而实现进程的互斥、同步</p>
<p>对信号量S可以实施的操作：初始化、P操作和V操作</p>
<p>初始化完成后，只有P、V操作才能改变其值</p>
<ul>
<li><p><code>P(s)/wait(s)</code>：s–（<strong>申请</strong>），若 s&lt;0 则等待，否则继续（这里的s是<strong>记录型变量</strong>）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">P</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// down, semWait</span>
<span class="token punctuation">&#123;</span>
    s<span class="token punctuation">.</span>count <span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        该进程状态置为阻塞状态<span class="token punctuation">;</span>
        将该进程插入相应的等待队列s<span class="token punctuation">.</span>quene末尾<span class="token punctuation">;</span>
        重新调度<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>V(s)/signal(s)</code>：s++（<strong>释放</strong>），若 s&lt;&#x3D;0 ，唤醒一个等待的P</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">V</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// up, semSignal</span>
<span class="token punctuation">&#123;</span>
    s<span class="token punctuation">.</span>count <span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        唤醒相应等待队列s<span class="token punctuation">.</span>quene中等待的一个进程<span class="token punctuation">;</span>
        改变其状态为就绪态，并将其插入就绪队列<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol>
<li><p>整型信号量：表示系统中某种资源的数量，如某系统中有一台打印机。存在“忙等”问题</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">wait</span> <span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// wait 原语（不能被中断）相当于“进入区”</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>S <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果资源数不够，就一直循环等待（问题：会发生“忙等”，违反“让权等待”原则）</span>
    S<span class="token operator">=</span>S<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 如果资源数够，则占用一个资源</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">signal</span> <span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    S<span class="token operator">=</span>S<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>记录型信号量：用记录型数据结构表示</p>
</li>
<li><p>AND型信号量：将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它可分配的资源也不分配给该进程。从而避免死锁</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">Swait</span><span class="token punctuation">(</span>Dmuten<span class="token punctuation">,</span> Emutex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Dmutex <span class="token operator">>=</span><span class="token number">1</span> and Emutex <span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>信号量集：对AND信号量加以扩充，在每次分配前，都必须测试资源的数量，看是否大于其下限值，并可按要求一次性分配多个资源</p>
</li>
</ol>
<hr>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>实现进程互斥：</p>
<ul>
<li>设置互斥信号量<code>mutex</code>，初值为1</li>
<li>在临界区之前执行P操作</li>
<li>在临界区之后执行V操作</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">semaphore mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    临界区代码段<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>

<span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    临界区代码段<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
   	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意：对不同的临界资源需要设置不同的互斥信号量。PV操作必须成对出现</p>
<p>实现进程同步：</p>
<ul>
<li>分析发生“同步关系”的位置</li>
<li>设置同步信号量S，初始为0</li>
<li>在前操作之后执行V操作</li>
<li>在后操作之后执行P操作</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">semaphore S<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    代码<span class="token number">1</span><span class="token punctuation">;</span>
    代码<span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    代码<span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    代码<span class="token number">4</span><span class="token punctuation">;</span>
    代码<span class="token number">5</span><span class="token punctuation">;</span>
    代码<span class="token number">6</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>实现前驱关系：</p>
<ul>
<li>要为每一对前驱关系各设置一个同步变量</li>
<li>在前操作之后对相应的同步变量执行V操作</li>
<li>在后操作之前对相应的同步变量执行P操作</li>
</ul>
<hr>
<h4 id="demo：生产者－消费者问题"><a href="#demo：生产者－消费者问题" class="headerlink" title="demo：生产者－消费者问题"></a>demo：生产者－消费者问题</h4><p>问题描述：</p>
<ol>
<li>一个或多个生产者生成某种类型的数据放置在缓冲区中</li>
<li>有消费者从缓冲区中取数据，每次取一项</li>
<li>只能有一个生产者对缓冲区进行操作</li>
</ol>
<p>要解决的问题：</p>
<ol>
<li>当缓冲区已满时，生产者不会继续向其中添加数据</li>
<li>当缓冲区为空时，消费者不会从中移走数据</li>
</ol>
<p>正确性要求：</p>
<ul>
<li>在任何一个时间只能有一个线程操作缓冲区（互斥）</li>
<li>当缓冲区为空，消费者必须等待生产者（同步）</li>
<li>当缓冲区满，生产者必须等待消费者（同步）</li>
<li>需要三个信号量（每个要求需要一个单独的信号量）：二进制信号量；一般信号量fullBuffers；一般信号量emptyBuffers</li>
</ul>
<p>初始化：设开始时buffer为空，生产者可以往buffer添加n个单位</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Class BoundedBuffer<span class="token punctuation">&#123;</span>
    mutex <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fullBuffers <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    emptyBuffers <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>生产者：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BoundedBuffer<span class="token operator">::</span><span class="token function">Deposit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    emptyBuffers<span class="token operator">-></span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生产</span>
    mutex<span class="token operator">-></span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Add c to the buffer<span class="token punctuation">;</span>
    mutex<span class="token operator">-></span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// mutex的PV操作保证互斥</span>
    fullBuffers<span class="token operator">-></span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 有货，来取</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>消费者：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BoundedBuffer<span class="token operator">::</span><span class="token function">Remove</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    fullBuffers<span class="token operator">-></span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 消费</span>
    mutex<span class="token operator">-></span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Remove c from the buffer<span class="token punctuation">;</span>
    mutex<span class="token operator">-></span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// mutex的PV操作保证互斥</span>
    emptyBuffers<span class="token operator">-></span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 空仓，生产</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<hr>
<h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><p>高级同步机制：管程（monitor，Java中称为监视器，对应的关键字为<code>synchronized</code>），不用关注复杂的PV操作</p>
<p>管程是一个特殊（软件）模块，包括对描述共享资源的数据结构以及对该结构的操作的一组过程（即函数）</p>
<p>基本特征：</p>
<ul>
<li>管程中的数据只能被管程中的过程访问；</li>
<li>一个进程仅通过调用管程内的进程才能进入管程访问共享数据；</li>
<li>管程是互斥进入的，每次仅<strong>允许一个进程</strong>在管程内执行某个内部过程</li>
</ul>
<p>语法描述：</p>
<ul>
<li>管程的名字</li>
<li>变量（初始值）</li>
<li>一组过程</li>
</ul>
<h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>设置<strong>条件变量（condition），等待（wait）&#x2F;唤醒（signal）</strong>操作来解决同步问题</p>
<ul>
<li>条件变量：管程内的等待机制<ul>
<li>进入管程的进&#x2F;线程因资源被占用而进入等待状态</li>
<li>每个条件变量表示一种等待原因，对应一个等待队列</li>
</ul>
</li>
<li>wait()：<ul>
<li>将自己阻塞在等待队列</li>
<li>唤醒一个等待者或释放管程的互斥访问</li>
</ul>
</li>
<li>signal()：<ul>
<li>将等待队列中的一个进&#x2F;线程唤醒</li>
<li>如果等待队列为空，则等同空操作</li>
</ul>
</li>
</ul>
<hr>
<h2 id="经典IPC问题"><a href="#经典IPC问题" class="headerlink" title="经典IPC问题"></a>经典IPC问题</h2><h3 id="多生产者－多消费者问题"><a href="#多生产者－多消费者问题" class="headerlink" title="多生产者－多消费者问题"></a>多生产者－多消费者问题</h3><p>案例：桌上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子等着吃盘子中的橘子，女儿等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取水果</p>
<p>分析：</p>
<ul>
<li>互斥关系：盘子是共享资源，访问需要互斥</li>
<li>同步关系：父亲－&gt;女儿；母亲－&gt;儿子。“盘子为空”这个事件可由儿子或女儿触发，事件发生后才允许父亲或母亲放水果。</li>
</ul>
<p>设计：</p>
<p>互斥关系：对盘子的互斥访问，初值为 mutex&#x3D;1</p>
<p>同步关系：同步信号量的初始值要看对应资源的初始值是多少（这里apple&#x3D;0，orange&#x3D;0）盘子容量的初始值为plate&#x3D;1</p>
<hr>
<h3 id="读者－写者问题"><a href="#读者－写者问题" class="headerlink" title="读者－写者问题"></a>读者－写者问题</h3><p>多个进程共享一个数据区，这些进程分为两组：</p>
<ul>
<li>读者进程：只在数据区中读数据，不会清空数据</li>
<li>写者进程：只往数据区中写数据</li>
</ul>
<p>要求：</p>
<ul>
<li>允许多个读者同时执行读操作（读进程不排斥其他读进程）</li>
<li>不允许多个写者同时操作</li>
<li>不允许读者、写者同时操作（写进程排斥其他所有进程）</li>
</ul>
<p>问题分析：</p>
<ul>
<li>互斥关系：写－写、读－读</li>
<li>同步关系：（即上面的要求）</li>
</ul>
<h4 id="解法一：读者优先"><a href="#解法一：读者优先" class="headerlink" title="解法一：读者优先"></a>解法一：读者优先</h4><p>如果读者执行：</p>
<ul>
<li>无其他读者、写者，该读者可以读</li>
<li>若已有写者等，但有其他读者正在读，则该读者也可以读</li>
<li>若有写者正在写，该读者必须等</li>
</ul>
<p>如果写者执行：</p>
<ul>
<li>无其他读者、写者，该写者可以写</li>
<li>若有读者正在读，该写者等待</li>
<li>若有其他写者正在写，该写者等待</li>
</ul>
<p>初始化</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">rw <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用于实现对文件的读写互斥访问</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 记录当前有几个读者在访问文件</span>
mutex <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用于保证对count变量的互斥访问</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p>读者：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证各读者互斥</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 第一个读者读</span>
            <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻止写进程</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 读者计数器加1</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        读文件
        
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证各读者互斥</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 读者计数器减1</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//当最后一个读者读完文件</span>
            <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许写进程</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>写者：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
         <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 互斥访问</span>
         
         写文件
         
         <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放资源</span>
         
         <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>问题：当不断有读者进来，那么写者就一直被阻塞等待，可能产生“饥饿”</p>
<hr>
<h4 id="解法二：写者优先"><a href="#解法二：写者优先" class="headerlink" title="解法二：写者优先"></a>解法二：写者优先</h4><p>保证一个写进程声明想写时，不允许新的读进程访问该数据区</p>
<hr>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>场景：5个哲学家，5把叉子，5盘意大利面（需要两把叉子才能吃）。哲学家的活动方式为：要么放下左右手叉子进行思考，要么拿起刀叉开始吃饭，且只有者两种交替状态</p>
<p>问题分析：</p>
<ul>
<li>关系分析：5个哲学家，每个与左右邻居对其中间的叉子的访问是互斥关系</li>
<li>整理思路：每个哲学家需要同时持有两个临界资源才能开始吃饭，<strong>如何避免出现死锁现象</strong>是关键</li>
<li>信号量：定义5把叉子的信号量数组<code>&#123;1,1,1,1,1&#125;</code>，哲学家（0~4）i左边的叉子编号为i，右边的为<code>(i+1)%5</code></li>
</ul>
<hr>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote>
<p>是一个处理器调度和资源分配的<strong>基本单元</strong>，也是程序执行流的最小单位，可以理解为“轻量级进程”</p>
</blockquote>
<p>每个线程都有一个线程ID、线程控制块（TCB）</p>
<p>引入线程后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务</p>
<p>多线程：指操作系统在单个进程内支持多个并发执行路径的能力</p>
<p>执行路径：即处理器执行指令的执行顺序</p>
<h2 id="与进程的区别"><a href="#与进程的区别" class="headerlink" title="与进程的区别"></a>与进程的区别</h2><p>进程中<strong>所有线程共享该进程的状态和资源，所有线程都驻留在同一地址空间中，并可访问相同的数据</strong></p>
<ol>
<li>调度的基本单位：无线程操作系统中，进程作为独立调度和分派的基本单位，在每次被调度时，都需要进行<strong>上下文切换</strong>，开销大；有线程操作系统中，线程作为调度和分派的基本单位。当线程切换时，仅需<strong>保存和设置少量寄存器内容</strong>，切换代价远低于进程，且在同一进程中，线程的切换不会引起进程的切换</li>
<li>并发性：在引入线程的操作系统中，不仅<strong>进程之间</strong>可以并发执行，而且在<strong>一个进程中的多个线程之间</strong>亦可并发执行。<strong>不同进程间的线程</strong>也能并发执行。从而有效地提高系统资源的利用率和吞吐量</li>
<li>拥有资源：<strong>进程可以拥有资源</strong>，而<strong>线程本身并不拥有资源</strong>，而仅有一些必要的、能保证独立运行的资源。<strong>多个线程共享进程所拥有的资源</strong></li>
<li>独立性：在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多</li>
<li>系统开销：线程轻量级，开销小</li>
<li>支持多处理机</li>
</ol>
<hr>
<h2 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h2><p>类似于进程，线程也具有执行状态，且可彼此同步</p>
<p>线程状态：和进程一样，线程的主要状态有运行态、就绪态和阻塞态</p>
<p>与线程状态改变相关的操作：</p>
<ul>
<li>派生：在派生一个新进程时，同时也会为该进程派生一个线程。随后，进程中的线程可在同一个进程中派生另一个线程，并为新线程提供指令指针和参数；新线程拥有自己的寄存器上下文和栈空间，并放在就绪队列中</li>
<li>阻塞：线程需要等待一个事件时会被阻塞（保存线程的用户寄存器、程序计数器和栈指针），处理器转而执行另一个就绪线程</li>
<li>解除阻塞</li>
<li>结束：一个线程完成后会释放其寄存器上下文和栈</li>
</ul>
<hr>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>用户级线程（User-Level Thread, ULT）：由应用程序通过线程库实现，所有的线程管理工作都由<strong>应用程序</strong>负责（包括线程切换）</p>
<p>内核级线程（Kernel-Level Thread, KLT）：管理工作由<strong>操作系统内核</strong>完成，包括线程调度、切换等，因此内核级线程的切换必须在<strong>核心态</strong></p>
<hr>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>实质上是一种资源分配</p>
<h2 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h2><p>WHAT：调度算法</p>
<p>WHEN：调度时机</p>
<p>HOW：进程</p>
<hr>
<h2 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h2><p>典型事件：</p>
<ul>
<li>创建、唤醒、退出等进程控制操作</li>
<li>进程等待IO、IO中断</li>
<li>时钟中断，如时间片用完，计时器到时</li>
<li>进程执行过程中出现abort异常</li>
</ul>
<p>当内核对中断&#x2F;异常&#x2F;系统调用做出处理时都是<strong>调度时机</strong></p>
<hr>
<h2 id="调度过程（进程切换）"><a href="#调度过程（进程切换）" class="headerlink" title="调度过程（进程切换）"></a>调度过程（进程切换）</h2><p>进程切换的代价：开销（cost）</p>
<ul>
<li>直接开销：内核完成切换所用的CPU时间，包含保存和恢复寄存器、切换地址空间（相关指令比较昂贵）</li>
<li>间接开销：高速缓存（Cache）失效、缓冲区缓存失效和TLB（快表）失效</li>
</ul>
<p>场景：进程A下CPU，进程B上CPU</p>
<ol>
<li>保存进程A的上下文环境（程序计数器、程序状态字、其他寄存器等）</li>
<li>用新状态和其他相关信息更新进程A的PCB</li>
<li>把进程A移至合适的队列（就绪、阻塞等）</li>
<li>将进程B的状态设置为运行态</li>
<li>从进程B的PCB中恢复上下文</li>
</ol>
<hr>
<h2 id="调度层次"><a href="#调度层次" class="headerlink" title="调度层次"></a>调度层次</h2><p>长程调度（作业调度、高级调度）：对象是作业。根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列（外存与内存之间的调度，每个作业只调入一次，调出一次）</p>
<p>注：进程挂起时会被调到外存，但PCB不会被调到外存</p>
<p>中程调度（内存调度、中级调度）：决定将哪个处于挂起状态的进程重新调入内存</p>
<p>短程调度（进程调度、低级调度）：对象是进程（或LWP）。根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514211512314.png" alt="image-20240514211512314"></p>
<hr>
<h2 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h2><p>作业：不仅包含了通常的程序和数据，而且配有一份作业说明书，系统根据该说明书对系统的运行进行控制</p>
<p>周转时间 &#x3D; 作业完成时间 - 作业提交时间</p>
<p>带权周转时间 &#x3D; 作业周转时间 &#x2F; 作业实际运行的时间 &#x3D; (作业完成时间 - 作业提交时间) &#x2F; 作业实际运行的时间</p>
<p>等待时间 &#x3D; 开始时刻 - 到达时刻</p>
<p>响应时间：从用户提交请求到首次产生响应所用的时间</p>
<hr>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>进程优先级：表示进程的重要性和紧迫性</p>
<p>优先数：表示优先级的一个数值</p>
<p>静态优先级：在创建进程时确定的，其在进程的整个运行期间保持不变</p>
<p>动态优先级：在创建进程之初，先赋予进程一个优先级，然后优先级会随进程的推进或等待时间的增加而改变，以便获得更好的调度性能</p>
<p>抢占式：当有比正在运行的进程优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU，提供给具有更高优先级的进程使用</p>
<p>非抢占式：继续运行</p>
<p>时间片：是一个时间段，分配给调度上CPU的进程，确定了允许该进程运行的时间长度</p>
<hr>
<h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><ul>
<li><p>CPU利用率：指cpu的有效工作时间占总时间的比例</p>
</li>
<li><p>系统吞吐量：单位时间内完成作业的数量 &#x3D; <code>作业数 / 时间</code></p>
</li>
<li><p>周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p>
<p><code>周转时间 = 作业完成时间 - 作业提交时间</code></p>
<p><code>平均周转时间 = 各作业周转时间之和 / 作业数</code></p>
<p><code>带权周转时间 = 作业周转时间 / 作业实际运行的时间</code></p>
</li>
<li><p>等待时间：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低</p>
</li>
<li><p>响应时间：从用户提交请求到首次产生响应所用的时间</p>
</li>
</ul>
<hr>
<h3 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h3><ul>
<li><p>先来先服务（FCFS）：<strong>先进先出</strong>（FIFO），非抢占式算法</p>
</li>
<li><p>最短作业优先（SJF）：具有<strong>最短完成时间的进程优先执行</strong>，即要求服务时间最短</p>
</li>
<li><p>最短剩余时间优先（SRTN）：SJF抢占式版本，<strong>当一个新就绪的进程比当前运行进程具有更短的完成时间</strong>，系统抢占当前进程，选择新就绪的进程执行</p>
</li>
<li><p>最高响应比优先（HRRN）：考虑到各个作业的等待时间，也能兼顾运行时间。计算响应比R，选择R最高的进程执行：</p>
<p><code>响应比R = 周转时间 / 处理时间 = （处理时间 + 等待时间）/ 处理时间 = 1+ （等待时间 / 处理时间） </code></p>
</li>
</ul>
<hr>
<h3 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h3><ul>
<li><p>轮转调度（RR）：轮流让各个进程执行一个时间片，用完时间片但是未执行完则被中断，重新放到就绪队列队尾排队</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514215631657.png" alt="image-20240514215631657"></p>
</li>
<li><p>最高优先调度（HPF）：选择优先级最高的进程投入运行。通常<strong>系统进程优先级高于用户进程</strong>；<strong>前台进程优先级高于后台进程</strong>；操作系统更偏好IO型进程</p>
</li>
<li><p>多级队列调度（MQ）</p>
</li>
<li><p>多级反馈队列（MFQ）</p>
</li>
</ul>
<p>时间片问题：</p>
<ul>
<li>如果时间片太长（长于典型的交互时间）：降级为先来先服务算法，延长短进程的相应时间</li>
<li>如果时间片太短（短于典型的交互时间）：进程频繁切换浪费CPU时间</li>
</ul>
<hr>
<h3 id="实时系统调度算法"><a href="#实时系统调度算法" class="headerlink" title="实时系统调度算法"></a>实时系统调度算法</h3><p>硬实时系统：要求在指定的时间内必须完成任务</p>
<p>软实时系统：要求在指定的时间内尽量完成任务</p>
<ul>
<li><p>最早截止时间优先算法（EDF）：根据<strong>任务的截止时间</strong>确定任务的优先级。任务的截止时间越早，其优先级越高</p>
</li>
<li><p>最低松弛度优先（LLF）：根据<strong>任务的紧急或松弛程度</strong>来确定优先级。松弛度最低的优先级最高</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">例如，1个任务要在200ms时必须完成，其本身的执行时间为100ms，则松弛度为100ms；1个任务要在400ms时完成，其本身的执行时间为150ms，则松弛度为250ms<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<hr>
<h2 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h2><h3 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h3><p>定义：一组进程中，每个进程都<strong>无限等待</strong>被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为<strong>进程死锁</strong>，这一组进程就称为<strong>死锁进程</strong></p>
<p>参与死锁的进程是被阻塞的，无法上CPU</p>
<p>活锁：先加锁，再轮询。既无进展也无阻塞。能上CPU，但只能忙等</p>
<p>饥饿：长期得不到想要的资源，而无法上CPU</p>
<p>产生死锁的必要条件：</p>
<ul>
<li>互斥使用：一个资源每次只能给一个进程使用</li>
<li>占有且等待：进程在申请新的资源的同时保持对原有资源的占有</li>
<li>不可抢占：资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放</li>
<li>循环等待（环路等待）</li>
</ul>
<p>死锁发生时，以上四个条件一定是<strong>同时满足</strong>的，如果其中任何一个条件不成立，死锁就不会发生</p>
<p>注发生死锁时一定有循环等待，但是发生循环等待时未必有死锁</p>
<hr>
<h3 id="死锁建模"><a href="#死锁建模" class="headerlink" title="死锁建模"></a>死锁建模</h3><ul>
<li>圆形：进程节点</li>
<li>方形：资源节点</li>
<li>从资源节点到进程节点的有向边：该资源已被请求、授权并被进程占用</li>
<li>从进程节点到资源节点的有向边：当前进程正在请求该资源，并且该进程已被阻塞，处于等待状态</li>
</ul>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514220409361.png" alt="image-20240514220409361"></p>
<hr>
<h3 id="处理死锁的策略"><a href="#处理死锁的策略" class="headerlink" title="处理死锁的策略"></a>处理死锁的策略</h3><ul>
<li>忽略该问题</li>
<li>避免死锁：仔细分配资源，动态地避免死锁</li>
<li>预防死锁：通过破坏引起死锁的4个必要条件之一，防止死锁的发生</li>
<li>检测死锁并恢复（解除）：让死锁发生，检测它们是否发生，一旦发生，采取行动解决</li>
</ul>
<h4 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h4><blockquote>
<p>假装无事发生</p>
</blockquote>
<hr>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><blockquote>
<p>在系统运行过程中，对进程请求的资源进行动态检查，并根据检查结果决定是否分配资源，若分配后系统发生死锁或可能发生死锁，则不予分配，否则予以分配</p>
</blockquote>
<p>考虑一个系统，它有<strong>固定数量的进程和固定数量的资源</strong>，任何时刻一个进程可能分配到零个或多个资源</p>
<ul>
<li>安全序列：如果系统按照这种序列分配资源，则所有进程都能顺利完成。只要能找出一个安全序列，系统就处于<strong>安全状态</strong>。<strong>安全序列可能有多个</strong></li>
<li>不安全状态：如果分配资源后，系统找不出任何一个安全序列，则系统进入<strong>不安全状态</strong>。当然，如果有进程提前归还了一些资源，则系统有可能重新回到安全状态</li>
</ul>
<p>系统处于安全状态，就一定不会发生死锁；如果系统进入不安全状态，就有可能发生死锁。处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态</p>
<p>两个状态的区别：从安全状态出发，系统能保证所有进程都能完成；而从不安全状态出发，就无法保证</p>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><blockquote>
<p>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会，就暂时不答应这次请求，让该进程先阻塞等待</p>
</blockquote>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514221633301.png" alt="image-20240514221633301"></p>
<p>检查一个状态是否安全的算法：</p>
<ul>
<li><p>查找右边矩阵中是否有一行，其没有被满足的资源数均小于等于A。如果不存在，那么系统将会死锁，因为任何进程都无法运行结束</p>
</li>
<li><p>假如找到这样一行，那么可以假设它获得所需的资源并运行结束，将该进程标记为终止，并将其资源加到向量A上</p>
</li>
<li><p>重复以上两步，或者直到所有的进程都标记为终止，其初始状态是安全的；反之，发生死锁</p>
</li>
</ul>
<hr>
<h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><ol>
<li>破坏互斥条件：一般来说无法破坏</li>
<li>破坏占有且等待条件：</li>
<li>破坏不可抢占条件：当一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源</li>
<li>破坏循环等待条件：采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源</li>
</ol>
<hr>
<h4 id="死锁检测和死锁恢复"><a href="#死锁检测和死锁恢复" class="headerlink" title="死锁检测和死锁恢复"></a>死锁检测和死锁恢复</h4><p>死锁检测</p>
<p>死锁恢复：</p>
<ol>
<li>利用抢占恢复</li>
<li>利用回滚恢复：设置进程检查点</li>
<li>通过杀死进程恢复</li>
</ol>
<hr>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="内存基础"><a href="#内存基础" class="headerlink" title="内存基础"></a>内存基础</h2><p>帕金森定律：不管存储器有多大，程序都可以把它填满</p>
<p>内存是用于存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理</p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-31-43-197_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-31-43-197_com.orion.notein-edit"></p>
<ul>
<li>主存储器（内存）：用于保存进程运行时的程序和数据</li>
<li>寄存器：是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果，对寄存器的访问速度最快</li>
<li>高速缓存（Cache）：主要用于备份主存中较常用的数据，以减少处理机对内存的访问次数，提高程序执行速度。为了缓和内存与处理机速度之间的矛盾</li>
<li>磁盘缓存：暂时存放频繁使用的一部分磁盘数据和信息，减少访问磁盘的次数</li>
</ul>
<p>寄存器和主存储器被称为<strong>可执行存储器</strong></p>
<hr>
<h2 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h2><p>方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。但是需要存储在连续的地址</p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-35-01-609_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-35-01-609_com.orion.notein-edit"></p>
<p>方法二：采用重定位寄存器（基址寄存器）和界址寄存器（限长寄存器）进行越界检查，重定位寄存器中存放的是进程的起始<strong>物理地址</strong>；界址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。可用于非连续存储或虚拟内存</p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-36-08-047_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-36-08-047_com.orion.notein-edit"></p>
<hr>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><ol>
<li>编译：由编译程序将用户源代码编译成若干目标模块（高级 -&gt; 机器）</li>
<li>链接：由链接程序将编译后的目标模块和<strong>所需库函数</strong>链接在一起，形成一个完整的装入程序</li>
<li>装入：由装入程序将装入模块装入内存运行</li>
</ol>
<p>物理地址：物理内存中实际地址</p>
<p>逻辑地址：相对于程序开始地址的地址</p>
<p>绝对装入：直接访问物理内存，导致同时运行两个程序可能导致崩溃，不同时运行也可能崩溃</p>
<p>地址空间：一个进程可用于寻址内存的一套地址集合，独立于其他进程</p>
<h3 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h3><p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-41-44-410_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-41-44-410_com.orion.notein-edit"></p>
<p>又称为<strong>可重定位装入</strong>，编译、链接后的装入模块的地址都是从0开始的。指令中使用的地址，数据存放的地址都是相对于起始地址而言的逻辑地址。装入内存后，对地址进行“重定位”</p>
<p>特点：在一个作业装入内存时，必须分配其要求的全部内存空间。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间</p>
<h3 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h3><p>又称为动态运行时装入，编译、链接后的装入模块的地址都是从0开始的，装入内存后，并不会立即进行转换，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存的依然是逻辑地址。需要<strong>重定位寄存器</strong>支持。允许程序在内存中发生移动</p>
<blockquote>
<p>模块在内存中的起始地址 + 目标内存单元相对于起始位置的偏移量</p>
</blockquote>
<hr>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><p>链接程序的功能是将目标模块以及它们所需的库函数装配成一个完整的装入模块</p>
<p>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完成的可执行文件，之后不再拆开</p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-45-00-617_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-45-00-617_com.orion.notein-edit"></p>
<p>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。其优点是便于修改和更新，以及实现对目标模块的共享</p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-45-52-878_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-45-52-878_com.orion.notein-edit"></p>
<p>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。优点是加快程序的装入过程，且节省内存空间</p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-46-25-544_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-46-25-544_com.orion.notein-edit"></p>
<hr>
<h2 id="连续分配存储方式"><a href="#连续分配存储方式" class="headerlink" title="连续分配存储方式"></a>连续分配存储方式</h2><p>程序装入内存前，必须为它分配一定大小的存储空间</p>
<p>内存分配会导致碎片问题：</p>
<p>内部碎片：分配给某个进程的内存区域中，有空闲</p>
<p>外部碎片：内存中的某些空闲分区由于太小而无法分配。可采用紧凑技术来解决</p>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-50-15-757_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-50-15-757_com.orion.notein-edit"></p>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>将整个用户空间划分为若干固定大小的区域</p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-51-49-510_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-51-49-510_com.orion.notein-edit"></p>
<p>优点：简单，无外部碎片</p>
<p>缺点：内存利用率低。程序太大而分区太小，使用覆盖技术设计程序；程序太小也要占用整个分区，从而导致内部碎片</p>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ul>
<li>对应的数据结构：空闲分区表和空闲分区链</li>
</ul>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-01-26-907_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-01-26-907_com.orion.notein-edit"></p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-02-10-097_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-02-10-097_com.orion.notein-edit"></p>
<p>动态分区分配没有内部碎片，但有外部碎片</p>
<p>基于顺序搜索：首次适应、下次适配算法、最佳适配算法、最差适配算法</p>
<p>基于索引搜索：快速适应、伙伴系统、哈希算法</p>
<h4 id="首次适应算法（FF）"><a href="#首次适应算法（FF）" class="headerlink" title="首次适应算法（FF）"></a>首次适应算法（FF）</h4><blockquote>
<p>每次都从低地址开始查找，找到第一个能满足大小需求的空闲分区</p>
</blockquote>
<h4 id="下次适配算法（NF）"><a href="#下次适配算法（NF）" class="headerlink" title="下次适配算法（NF）"></a>下次适配算法（NF）</h4><blockquote>
<p>每次找到合适的空闲区时都记录当时的位置，以便在下次寻找空闲区时从上次结束的地方开始搜索</p>
</blockquote>
<h4 id="最佳适配算法（BF）"><a href="#最佳适配算法（BF）" class="headerlink" title="最佳适配算法（BF）"></a>最佳适配算法（BF）</h4><blockquote>
<p>搜索整个链表，找出能够容纳进程的最小空闲区，即试图找出最接近实际需要的空闲区</p>
</blockquote>
<h4 id="最差适配算法（WF）"><a href="#最差适配算法（WF）" class="headerlink" title="最差适配算法（WF）"></a>最差适配算法（WF）</h4><blockquote>
<p>该算法总是分配最大的可用空闲区，使新的空闲区比较大从而可以继续使用</p>
</blockquote>
<p>以上四种方法，随着时间的推移，内存中会形成越来越多的外部碎片，内存的利用率随之下降</p>
<hr>
<p>实际应用中，所有进程所需的内存容量通常要远远超出存储器能够支持的范围，现通用的方法有：交换技术和虚拟内存技术</p>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><blockquote>
<p>将程序分为多个段（模块）。常用的段常驻内存，不常用的段在需要时调入内存</p>
</blockquote>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-17-54-523_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-17-54-523_com.orion.notein-edit">                       </p>
<h3 id="交换技术-1"><a href="#交换技术-1" class="headerlink" title="交换技术"></a>交换技术</h3><blockquote>
<p>内存空间紧张时，系统将内存中暂时不能运行的或不用打进程（或数据）暂时移到外存（挂起），把外存中已具备运行条件的进程交换进内存</p>
</blockquote>
<hr>
<h2 id="地址空间结构"><a href="#地址空间结构" class="headerlink" title="地址空间结构"></a>地址空间结构</h2><p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-33-00-233_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-33-00-233_com.orion.notein-edit"></p>
<p>例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 全局初始化区</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>    <span class="token comment">// 全局未初始化区</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token comment">// 栈</span>
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 栈</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>    <span class="token comment">// 栈</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>    <span class="token comment">// 123456\0在常量区，p3在栈上</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 全局（静态）初始化区</span>
    p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 分配得来的区域在堆区</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h2><p>如果允许将一个进程分散地装入到许多不相邻的分区中，便可更充分地利用内容，从而产生<strong>非连续分配方式</strong></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>用户进程的地址空间被划分为大小相等的分区（或块），称为<strong>页</strong>或<strong>页面</strong>（page），从0开始编号</p>
<p>内存空间按同样大小划分为大小相等的块，称为<strong>页框</strong>（frame），或称物理页面、页帧、内存块，物理块等，也从0开始编号</p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-48-50-790_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-48-50-790_com.orion.notein-edit"></p>
<hr>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>系统以<strong>页框为单位</strong>为各个进程分配内存。典型的页面大小：4K或4M（大小必须是2的整数倍）</p>
<p>页面与页框是一一对应关系。逻辑上相邻的页，物理上不一定相邻。划分是系统自动完成的，对用户是透明的</p>
<p>分页技术会产生较少的内部碎片，<strong>没有任何外部碎片</strong></p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-58-47-088_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-58-47-088_com.orion.notein-edit"></p>
<p>计算：十进制数表示逻辑地址时，</p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240605220741911.png" alt="image-20240605220741911"></p>
<hr>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为<strong>每个进程建立一张页表</strong></p>
<p>页表项（PTE）：记录了逻辑页号与页框号的对应关系，存放在内存（或虚存），页表起始地址保存在<strong>页表寄存器</strong>中，其结构包括：</p>
<ul>
<li>页框号：物理页面号</li>
<li>有效位（在&#x2F;不在位）：1表示该页在内存，0表示不在内存</li>
<li>访问位：此页是否被访问过</li>
<li>修改位：此页在内存中是否被修改过</li>
<li>保护位：只读&#x2F;可读写</li>
<li>用户&#x2F;内核位，高速缓存禁止位等</li>
</ul>
<hr>
<h3 id="基址变换机构"><a href="#基址变换机构" class="headerlink" title="基址变换机构"></a>基址变换机构</h3><blockquote>
<p>负责将页表中的逻辑地址转换为物理地址</p>
</blockquote>
<p>通常会在系统中设置一个<strong>页表寄存器</strong>（PTR），存放页表在内存中的<strong>起始地址F</strong>和<strong>页表长度M</strong>。进程未执行时，页表的始址和页表长度放在<strong>进程控制块PCB</strong>中，当进程被调度时，系统内核会把它们放到PTR中</p>
<p><img src="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-30-17-19-27-735_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-30-17-19-27-735_com.orion.notein-edit"></p>
<hr>
<h3 id="地址转换-1"><a href="#地址转换-1" class="headerlink" title="地址转换"></a>地址转换</h3><ol>
<li>算出逻辑地址对应的页号 &#x3D; 逻辑地址 &#x2F; 页面长度（下取整）</li>
<li>获取该页号对应页面在内存中的起始地址</li>
<li>算出逻辑地址在页面内的逻辑量 &#x3D; 逻辑地址 % 页面长度</li>
<li>物理地址 &#x3D; 页面起始地址 + 页内偏移量</li>
</ol>
<hr>
<h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2>
    </div>
    
    
    
    
    
    
    
</div>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/blog/js/main.js"></script>
        
        




         
        
    <div id="vcomments"></div>
    
        <script src="/blog/js/lib/valine.min.js"></script>
            <script>
                new Valine({
                    el: '#vcomments',
                    app_id: 'U9mZLKunkRUTcBFthjXPjnZE-9Nh9j0Va',
                    app_key: 'SzWOnY0PWLGNuL6jW8TZYc7j',
                    visitor: 'true',
                    placeholder: '写点什么吧(●ˇ∀ˇ●)',
                    serverURLs: 'https://u9mzlkun.lc-cn-n1-shared.com',
                });
            </script>

        <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 雲流のLowest World
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;C1oudfL0w0
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

    <script src="/blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/blog/live2dw/assets/z16.model.json"},"display":{"position":"left","width":150,"height":290},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

